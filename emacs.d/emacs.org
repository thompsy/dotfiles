#+TITLE: emacs.org
#+PROPERTY: header-args:emacs-lisp :tangle ~/.emacs.d/init.el :results silent :exports code

* emacs.org
** What is this?
This is my emacs configuration in =org-mode=. To output the source code run ~org-babel-tangle~
(typically ~C-c~ ~C-v~ ~t~). This will output the relevant files into ~~/.emacs.d/~ where Emacs will pick
them up.

Many (most!) things in this file have been inspired by others making their configuration
available. A few places that I've found particularly useful include:
- [[https://github.com/kwpav/dotfiles/blob/master/emacs.org][kwpav's config]]
- [[http://pages.sachachua.com/.emacs.d/Sacha.html][Sacha Chua's config]]
- [[https://github.com/TheBB/dotemacs][TheBB's config]]
- [[https://github.com/jwiegley/dot-emacs][jwiegly's config]]
- [[https://github.com/syl20bnr/spacemacs][Spacemacs]]
- [[https://github.com/hlissner/doom-emacs][Doom Emacs]]
- [[https://github.com/MatthewZMD/.emacs.d#org0f80f62][M-EMACS]]
- [[https://github.com/ianpan870102/yay-evil-emacs/blob/master/config.org][yay-evil]]
- [[https://framagit.org/steckerhalter/steckemacs.el/-/tree/master][steckemacs]]

* TODO
** Try Yegge's keybindings
Take from [[https://www.irreal.org/blog/?p=10424]]:
- ~C-x t~ -> ~beginning-of-buffer~
- ~C-x e~ -> ~end-of-buffer~

** Experiment with ~treesit-font-lock-level~
** Explore ~transient-mark-mode~
See [[https://www.masteringemacs.org/article/fixing-mark-commands-transient-mark-mode]]
** Get Python up and running
** Figure out a way to autoload treesitter grammars
It would also be good to keep these up to date.
** Add format on save with ~eglot~
** Rationalise Hydra config across packages
** Rationalise General config across packages
** Have all hydras use q for quit
** Use ~:after~ to specify any dependencies
** Have ~project.el~ run the correct make target as compile command
** Corfu popup without hitting tab
- it might be nice to have this always popup with suggestions bars on the context e.g. Go, org etc. This might be Cape rather then Corfu
- this might be helpful https://emacs.stackexchange.com/questions/78237/automatic-popup-of-words-from-the-buffer-using-corfu-and-dabbrev
- this is useful context too https://www.reddit.com/r/emacs/comments/td0nth/sample_usage_of_cape_completion_at_point/
** Expore buffer placement options
See [[https://www.masteringemacs.org/article/demystifying-emacs-window-manager]]

* Org-mode
** Document tangling from the command line
See [[https://emacs.stackexchange.com/questions/27126/is-it-possible-to-org-bable-tangle-an-org-file-from-the-command-line]]
** Tags
Ideas here:
- [[https://karl-voit.at/2022/01/29/How-to-Use-Tags/]]
- [[https://takeonrules.com/2024/01/06/leveraging-denotes-signature-for-multiple-purposes//]]
** Workflows
Meetings:
- [[https://github.com/james-stoup/emacs-org-mode-tutorial]]

Other useful ideas here:
- [[https://dehora.net/journal/how-i-use-org-mode]]

* Packages to try
** ~dogears~
** ~urgrep~
** ~bookmarks+~
- we can bookmark buffers that aren't backed by files e.g. scratch
** ~wrep~
** ~tresitter-context~
** ~explain-pause-mode~
** ~visible-mark-mode~
** ~hyperbole~
** ~jinx~ for spelling
** ~expreg~
This is like ~expand-region~ but uses treesitter.
** Debugging with ~dape~
** ~org-autolist~
** ~org-sticky-header~
* Future Ideas
** Explore these configs
- [[https://old.reddit.com/r/emacs/comments/ehjcu2/screenshot_polishing_my_emacs_who_said_an_old/]]
- [[https://kristofferbalintona.me/posts/202202211546/]]
  - good ideas with Vertico etc here
- [[https://kristofferbalintona.me/posts/202202270056/]]
  - Corfu related config
- [[https://protesilaos.com/emacs/dotemacs]]
** Explore ~embark~ more

* Local
These are various, installation specific settings that might differ across machines, some of which I
don't want to commit to Git.

#+BEGIN_SRC emacs-lisp :tangle "~/.emacs.d/local.el" :eval no :mkdirp yes
  (provide 'local-setup)

  (setq user-full-name "Andrew Thompson"
        user-mail-address "github@downthewire.co.uk")

  (defconst my/org-dir
    "~/notebook/")

  (defconst my/org-agenda-files
    (list my/org-dir))
#+END_SRC

* Early Init
The ~early-init.el~ file is called very early in the initialisation process, so this is a good point
to disable ~package.el~ in favour of ~straight.el~.
#+BEGIN_SRC emacs-lisp :tangle "~/.emacs.d/early-init.el" :eval no
  ;; Startup speed, annoyance suppression
  (setq gc-cons-threshold 10000000)
  (setq byte-compile-warnings '(not obsolete))
  (setq warning-suppress-log-types '((comp) (bytecomp)))
  (setq native-comp-async-report-warnings-errors 'silent)

  ;; Silence stupid startup message
  (setq inhibit-startup-echo-area-message (user-login-name))

  ;; Default frame configuration: full screen, good-looking title bar on macOS
  (setq frame-resize-pixelwise t)
  (tool-bar-mode -1)                      ; All these tools are in the menu-bar anyway
  (setq default-frame-alist '((fullscreen . maximized)

  			    ;; You can turn off scroll bars by uncommenting these lines:
  			    (vertical-scroll-bars . nil)
  			    (horizontal-scroll-bars . nil)

  			    ;; Setting the face in here prevents flashes of
  			    ;; color as the theme gets activated
  			    (background-color . "#000000")
  			    (ns-appearance . dark)
  			    (ns-transparent-titlebar . t)))

  (setq package-enable-at-startup nil)
#+END_SRC

* Preamble
Some initial comment blurb.
#+BEGIN_SRC emacs-lisp
  ;;; init.el --- Initialization file for Emacs
  ;;; Commentary: Emacs Startup File --- initialization for Emacs
  ;;; Code:
#+END_SRC

Load some local setup. As noted above, this is generally installation specific, so its easiest to
keep it in a separate file.
#+BEGIN_SRC emacs-lisp
  (require 'local-setup "~/.emacs.d/local.el")
#+END_SRC

* Bedrock Emacs
All of this is new, minimal stuff from bedrock emacs:
#+BEGIN_SRC emacs-lisp
  (setopt initial-major-mode 'fundamental-mode)  ; default mode for the *scratch* buffer
  (setopt display-time-default-load-average nil) ; this information is useless for most

  ;; Save history of minibuffer
  (savehist-mode)

  ;; Move through windows with Ctrl-<arrow keys>
  (windmove-default-keybindings 'control) ; You can use other modifiers here

  ;; Fix archaic defaults
  (setopt sentence-end-double-space nil)

  ;; Don't litter file system with *~ backup files; put them all inside
  ;; ~/.emacs.d/backup or wherever
  (defun bedrock--backup-file-name (fpath)
    "Return a new file path of a given file path.
  If the new path's directories does not exist, create them."
    (let* ((backupRootDir "~/.emacs.d/emacs-backup/")
  	 (filePath (replace-regexp-in-string "[A-Za-z]:" "" fpath )) ; remove Windows driver letter in path
  	 (backupFilePath (replace-regexp-in-string "//" "/" (concat backupRootDir filePath "~") )))
      (make-directory (file-name-directory backupFilePath) (file-name-directory backupFilePath))
      backupFilePath))
  (setopt make-backup-file-name-function 'bedrock--backup-file-name)

#+END_SRC

* Package Manager
Setup the [[https://github.com/radian-software/straight.el][~straight.el~]] package manager.
#+BEGIN_SRC emacs-lisp
  (setq straight-repository-branch "master")

  (defvar bootstrap-version)
  (let ((bootstrap-file
         (expand-file-name "straight/repos/straight.el/bootstrap.el" user-emacs-directory))
        (bootstrap-version 5))
    (unless (file-exists-p bootstrap-file)
      (with-current-buffer
          (url-retrieve-synchronously
           "https://raw.githubusercontent.com/raxod502/straight.el/develop/install.el"
           'silent 'inhibit-cookies)
        (goto-char (point-max))
        (eval-print-last-sexp)))
    (load bootstrap-file nil 'nomessage))
#+END_SRC

From the straight docs:
#+BEGIN_QUOTE
By setting the variable straight-cache-autoloads to a non-nil value, you can cause straight.el to
cache the autoloads of all used packages in a single file on disk, and load them from there instead
of from the individual package files if they are still up to date. This reduces the number of disk
IO operations during startup from O(number of packages) to O(1), so it should improve
performance. No other configuration should be necessary to make this work; however, you may wish to
call straight-prune-build occasionally, since otherwise this cache file may grow quite large over
time.
#+END_QUOTE
#+BEGIN_SRC emacs-lisp
  (setq straight-cache-autoloads t)
#+END_SRC

In addition:
#+BEGIN_QUOTE
You may customize straight-use-package-by-default to make it so that :straight t is assumed unless
you explicitly override it with :straight nil.
#+END_QUOTE

#+BEGIN_SRC emacs-lisp
  (setq straight-use-package-by-default t)
#+END_SRC

todo: update this link
Install [[https://github.com/jwiegley/use-package][~use-package~]] for easily installing other packages.
#+BEGIN_SRC emacs-lisp
  ;; Install use-package to use with straight.el
  (straight-use-package 'use-package)
#+END_SRC

I don't want to use the built-in version of org-mode since it's usually pretty old. Instead I want
straight to pull down the latest version. To avoid the built-in version getting loaded we need to
explicitly load it with straight early in the init process. See more details in the [[https://github.com/radian-software/straight.el#the-wrong-version-of-my-package-was-loaded][~README.md~]].
#+BEGIN_SRC emacs-lisp
  (straight-use-package 'org)
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (setq use-package-always-demand t)
#+END_SRC
* Core Configuration
A few miscellaneous settings. Note that emacs is not really a package strictly speaking which is why we include ~:straight nil~ so that our package manager doesn't try to fetch the source.
#+BEGIN_SRC emacs-lisp
  (use-package emacs
    :straight nil
    :init
    ;; answer with y/n instead of typing out yes/no
    (defalias 'yes-or-no-p 'y-or-n-p)
    :config
    (setq indent-tabs-mode nil
          tab-width 4
          show-trailing-whitespace t
          fill-column 100)
    (setq-default indent-tabs-mode nil
                  fill-column 100)
    :custom
    ;; load new source files instead of stale elisp bytecode
    (load-prefer-newer t)
    ;; allow emacs to be any size, removes black bars
    (frame-resize-pixelwise t))
#+END_SRC

It's useful to have buffers auto-revert when files on disk change especially when using Git branches a lot!
#+BEGIN_SRC emacs-lisp
  (use-package autorevert
    :straight nil
    :custom
    (global-revert-check-vc-info t)
    :config
    (global-auto-revert-mode +1)
    ;; Automatically reread from disk if the underlying file changes
    (setopt auto-revert-avoid-polling t)
    ;; Some systems don't do file notifications well; see
    ;; https://todo.sr.ht/~ashton314/emacs-bedrock/11
    (setopt auto-revert-interval 5)
    (setopt auto-revert-check-vc-info t))
#+END_SRC

Use the system keyboard when killing and yanking.
#+BEGIN_SRC emacs-lisp
  (use-package simple
    :straight nil
    :custom
    ;; killing and yanking uses the system clipboard
    (save-interprogram-paste-before-kill t))
#+END_SRC

[[https://github.com/emacs-mirror/emacs/blob/master/lisp/saveplace.el][~saveplace~]] jumps back to
the last when later visiting a file. This is handy to pick up where you left off.
#+BEGIN_SRC emacs-lisp
  (use-package saveplace
    :straight nil
    :config
    (save-place-mode +1))
#+END_SRC

[[https://github.com/emacscollective/no-littering][~no-littering~]] keeps configuration files and
other persistent data under ~user-emacs-directory~ rather than spamming them in inconsistent places.
#+BEGIN_SRC emacs-lisp
  (use-package no-littering
    :init
    (setq no-littering-etc-directory
          (expand-file-name "etc/" user-emacs-directory)
          no-littering-var-directory
          (expand-file-name "var/" user-emacs-directory)))
#+END_SRC

Use a separate custom file to remove auto-generated code from ~init.el~. This should be loaded prior
to any themes so that they confirmation code gets stored in ~custom.el~.
#+BEGIN_SRC emacs-lisp
  (use-package cus-edit
    :straight nil
    :custom
    (custom-file (expand-file-name "custom.el" user-emacs-directory))
    :config
    (if (file-exists-p custom-file)
        (load-file custom-file)))
#+END_SRC

** Exec Path Setup
[[https://github.com/purcell/exec-path-from-shell][~exec-path-from-shell~]] loads the ~PATH~ from your shell setup. This is useful when running Emacs from
a non-shell environment like OSX.
#+begin_src emacs-lisp
  (use-package exec-path-from-shell
    :config
    (exec-path-from-shell-initialize))
#+end_src

** Files
Setup some basic file hygiene. Keep some backup files around, but keep them out of sight.

TODO verify that some of these aren't duplicated above
#+BEGIN_SRC emacs-lisp
  (use-package files
    :straight nil
    :init
    (recentf-mode 1)
    :config
    (setq backup-by-copying t
          backup-directory-alist '((".*" . "~/.emacs.d/backups/"))
          delete-old-versions t
          delete-auto-save-files t
          kept-new-versions 6
          kept-old-versions 2
          version-control t
          vc-make-backup-files t
          recentf-max-menu-items 25
          recentf-max-saved-items 500
          create-lockfiles nil
          auto-save-file-name-transforms
          `((".*" "~/.emacs.d/auto-saves/" t))))
#+END_SRC

Use UTF-8 everywhere.
#+BEGIN_SRC emacs-lisp
  (use-package mule
    :straight nil
    :config
    (prefer-coding-system 'utf-8-unix)
    (set-default-coding-systems 'utf-8-unix)
    (set-language-environment 'utf-8)
    (set-terminal-coding-system 'utf-8-unix)
    (setq locale-coding-system 'utf-8-unix)
    (set-selection-coding-system 'utf-8-unix))
#+END_SRC

Setup some basic file hygiene. Keep some backup files around, but keep them out of sight.
#+BEGIN_SRC emacs-lisp
  (use-package files
    :straight nil
    :config
    (setq backup-by-copying t
          backup-directory-alist '((".*" . "~/.emacs.d/backups/"))
          delete-old-versions t
          delete-auto-save-files t
          kept-new-versions 6
          kept-old-versions 2
          version-control t
          vc-make-backup-files t
          recentf-max-menu-items 25
          recentf-max-saved-items 500
          auto-save-file-name-transforms
          `((".*" "~/.emacs.d/auto-saves/" t))))
#+END_SRC

~uniqify~ renames buffers with the same name so that they're easier to distinguish.
#+BEGIN_SRC emacs-lisp
  (use-package uniquify
    :straight nil
    :config
    (setq uniquify-buffer-name-style 'forward
          uniquify-separator "/"
          ;; rename after killing uniquified
          uniquify-after-kill-buffer-p t
          ;; don't muck with special buffers
          uniquify-ignore-buffers-re "^\\*"))
#+END_SRC

** Discoverability
[[https://github.com/justbur/emacs-which-key][~which-key~]] displays all of the available keybindings following a incompletely entered command. For
example, pressing ~C-x~ and waiting a moment will cause ~which-key~ to populate the minibuffer with all
the available next keys along with their corresponding commands. This makes discovery of new
commands very easy.

The only slight issue with this is that the size of the minibuffer expands a lot which can cause the
view of the current buffer to change depending on where the point is. ~which-key-posframe~ provides an
improvement on this by popping up in a floating window. I'll try it for a while and see.

#+BEGIN_SRC emacs-lisp
  (use-package which-key
    :custom
    (which-key-idle-delay 0)
    :config
    (which-key-mode +1))
#+END_SRC

** Minibuffer/Completion settings
#+BEGIN_SRC emacs-lisp
  ;; For help, see: https://www.masteringemacs.org/article/understanding-minibuffer-completion
  (setopt enable-recursive-minibuffers t)                ; Use the minibuffer whilst in the minibuffer
  (setopt completion-cycle-threshold 1)                  ; TAB cycles candidates
  (setopt completions-detailed t)                        ; Show annotations
  (setopt tab-always-indent 'complete)                   ; When I hit TAB, try to complete, otherwise, indent
  (setopt completion-styles '(basic initials substring)) ; Different styles to match input to candidates

  (setopt completion-auto-help 'always)                  ; Open completion always; `lazy' another option
  (setopt completions-max-height 20)                     ; This is arbitrary
  (setopt completions-detailed t)
  (setopt completions-format 'one-column)
  (setopt completions-group t)
  (setopt completion-auto-select 'second-tab)            ; Much more eager
  					;(setopt completion-auto-select t)                     ; See `C-h v completion-auto-select' for more possible values

  (keymap-set minibuffer-mode-map "TAB" 'minibuffer-complete) ; TAB acts more like how it does in the shell
#+END_SRC

** Inteface Enhancements
#+BEGIN_SRC emacs-lisp
  ;; Mode line information
  (setopt line-number-mode t)                        ; Show current line in modeline
  (setopt column-number-mode t)                      ; Show column as well

  (setopt x-underline-at-descent-line nil)           ; Prettier underlines
  (setopt switch-to-buffer-obey-display-actions t)   ; Make switching buffers more consistent

  (setopt show-trailing-whitespace nil)      ; By default, don't underline trailing spaces
  (setopt indicate-buffer-boundaries 'left)  ; Show buffer top and bottom in the margin

  ;; Enable horizontal scrolling
  (setopt mouse-wheel-tilt-scroll t)
  (setopt mouse-wheel-flip-direction t)

  ;; We won't set these, but they're good to know about
  ;;
  ;; (setopt indent-tabs-mode nil)
  ;; (setopt tab-width 4)

  ;; Misc. UI tweaks
  (blink-cursor-mode -1)                                ; Steady cursor
  (pixel-scroll-precision-mode)                         ; Smooth scrolling

  ;; Use common keystrokes by default
  (cua-mode)

  ;; Display line numbers in programming mode
  (add-hook 'prog-mode-hook 'display-line-numbers-mode)
  (setopt display-line-numbers-width 3)           ; Set a minimum width

  ;; Nice line wrapping when working with text
  (add-hook 'text-mode-hook 'visual-line-mode)

  ;; Modes to highlight the current line with
  (let ((hl-line-hooks '(text-mode-hook prog-mode-hook)))
    (mapc (lambda (hook) (add-hook hook 'hl-line-mode)) hl-line-hooks))
#+END_SRC

* Aesthetics
Turn off a bunch of frame related functionality for a more minimal experience.
#+BEGIN_SRC emacs-lisp
  (use-package frame
    :straight nil
    :config
    (blink-cursor-mode -1)
    (setq initial-scratch-message ""
          inhibit-startup-message t
          visible-bell nil
          ring-bell-function 'ignore
          initial-frame-alist
          '((menu-bar-lines . 0)
            (tool-bar-lines . 0)))
    (scroll-bar-mode 0)
    (tool-bar-mode 0)
    (menu-bar-mode 0)
    (global-hl-line-mode 1))
#+END_SRC

[[https://draculatheme.com/emacs][Dracula]] is a nice theme that's available for lots of apps.
#+BEGIN_SRC emacs-lisp  
  (use-package dracula-theme
    :config
    (load-theme 'dracula))

  (add-to-list 'default-frame-alist '(font . "Fira Code-14"))

  (use-package all-the-icons)

  (use-package all-the-icons-completion
    :init
    (all-the-icons-completion-mode))
#+END_SRC

[[https://github.com/seagle0128/doom-modeline][~doom-modeline~]] is a fancy, fast and minimal mode-line. This required running ~M-x nerd-icons-install-fonts~ to install the required icon font.
#+BEGIN_SRC emacs-lisp
  (use-package doom-modeline
    :demand t
    :init
    (column-number-mode +1)
    (doom-modeline-mode +1)
    :config
    (setq doom-modeline-height 1)
    (set-face-attribute 'mode-line nil :height 150)
    (set-face-attribute 'mode-line-inactive nil :height 150)
    :custom
    (doom-modeline-vcs-max-length 50)
    (doom-modeline-buffer-file-name-style 'truncate-upto-project))
#+END_SRC

* Keybindings
[[https://github.com/noctuid/general.el][~general.el~]] provides a convenient method for binding
keys. It also integrates well with ~use-package~. In particular, this allows us to easily setup a
global leader key, ~my-leader-def~ and chain bindings from that.
#+BEGIN_SRC emacs-lisp
  (use-package general
    :custom
    (general-override-states '(insert emacs hybrid normal visual motion operator replace))
    :config
    (general-define-key
     "C-w" 'backward-kill-word
     "C-c C-k" 'kill-region
     "C-x C-k" 'kill-region
     "C-x C-m" 'execute-extended-command
     "C-x m" 'execute-extended-command
     "C-c C-m" 'execute-extended-command
     "C-c m" 'execute-extended-command
     )

    ;; Make general's keybindings take precedence over keys bound to other minor mode keymaps.
    (general-override-mode)

    ;; We need to call this so that we can allocate C-t as a prefix key. See
    ;; https://github.com/noctuid/general.el#automatic-key-unbinding for details.
    (general-auto-unbind-keys)
    ;; Create a definer where most of my commands will live under
    (general-create-definer my-leader-def
      :prefix "C-t")
    ;; Setup some initial bindings.
    ;; TODO some of these should probably live elsewhere
    (my-leader-def
      "m" 'execute-extended-command
      "a" 'org-agenda
      "b" '(:ignore t :wk "bookmarks")
      "bs" 'bookmark-set
      "bl" 'consult-bookmark
      ;; quit / restart
      "q" '(:ignore t :wk "quit / restart")
      "qq" 'save-buffers-kill-terminal
      "qQ" 'save-buffers-kill-emacs
      "qr" 'restart-emacs))
#+END_SRC

** Hydra
[[https://github.com/abo-abo/hydra][~hydra~]] allows us to specify related keybindings together in a
neat way. Note that ~:wk~ allows us to specify the text that is displayed by ~which-key~ for this hydra.
#+BEGIN_SRC emacs-lisp
  (use-package hydra)

  ;; This allows us to use :hydra within use-package
  (use-package use-package-hydra)
#+END_SRC

This hydra provides easy access to various package management commands.
#+BEGIN_SRC emacs-lisp
  (my-leader-def "s" '(hydra-straight-helper/body :wk "pkgs"))
  (defhydra hydra-straight-helper (:hint nil :color green)
    "
        _c_heck all       |_f_etch all     |_m_erge all      |_n_ormalize all   |p_u_sh all
        _C_heck package   |_F_etch package |_M_erge package  |_N_ormlize package|p_U_sh package
        ----------------^^+--------------^^+---------------^^+----------------^^+------------||_q_uit||
        _r_ebuild all     |_p_ull all      |_v_ersions freeze|_w_atcher start   |_g_et recipe
        _R_ebuild package |_P_ull package  |_V_ersions thaw  |_W_atcher quit    |prun_e_ build"
    ("c" straight-check-all)
    ("C" straight-check-package)
    ("r" straight-rebuild-all)
    ("R" straight-rebuild-package)
    ("f" straight-fetch-all)
    ("F" straight-fetch-package)
    ("p" straight-pull-all)
    ("P" straight-pull-package)
    ("m" straight-merge-all)
    ("M" straight-merge-package)
    ("n" straight-normalize-all)
    ("N" straight-normalize-package)
    ("u" straight-push-all)
    ("U" straight-push-package)
    ("v" straight-freeze-versions)
    ("V" straight-thaw-versions)
    ("w" straight-watcher-start)
    ("W" straight-watcher-quit)
    ("g" straight-get-recipe)
    ("e" straight-prune-build)
    ("q" nil))
#+END_SRC

This hydra gives easy access to inserting various Unicode characters.
#+BEGIN_SRC emacs-lisp
  (defun my/insert-unicode (unicode-name)
    "Same as C-x 8 enter UNICODE-NAME."
    (insert-char (gethash unicode-name (ucs-names))))

  (my-leader-def "u" '(hydra-unicode/body :wk "unicode"))
  (defhydra hydra-unicode (:hint nil)
    "
          Unicode  _e_ €  _g_ £
                   _f_ ♀  _r_ ♂
                   _o_ °  _m_ µ  _z_ ë  _Z_ Ë
                   _n_ ←  _e_ ↓  _i_ ↑  _o_ →
          "
    ("e" (my/insert-unicode "EURO SIGN"))
    ("g" (my/insert-unicode "POUND SIGN"))

    ("r" (my/insert-unicode "MALE SIGN"))
    ("f" (my/insert-unicode "FEMALE SIGN"))

    ("o" (my/insert-unicode "DEGREE SIGN"))
    ("m" (my/insert-unicode "MICRO SIGN"))

    ("z" (my/insert-unicode "LATIN SMALL LETTER E DIAERESIS"))
    ("Z" (my/insert-unicode "LATIN CAPITAL LETTER E DIAERESIS"))

    ("n" (my/insert-unicode "LEFTWARDS ARROW"))
    ("e" (my/insert-unicode "DOWNWARDS ARROW"))
    ("i" (my/insert-unicode "UPWARDS ARROW"))
    ("o" (my/insert-unicode "RIGHTWARDS ARROW")))
#+END_SRC

[[https://www.emacswiki.org/emacs/download/zoom-frm.el][~zoom-frm~]] is a nice way to zoom in and out on a frame basis. This is useful when switching from
smaller to larger screens.
#+begin_src emacs-lisp
  (use-package zoom-frm
    :general
    (my-leader-def "z" '(hydra-zoom/body :wk "zoom"))
    :hydra (hydra-zoom (:column 2)
                       ("n" zoom-frm-in "Zoom in")
                       ("t" zoom-frm-out "Zoom out")
                       ("r" (text-scale-set 0) "Reset zoom")
                       ("0" (text-scale-set 0) :bind nil :exit t)
                       ("q" nil "quit")))
#+END_SRC

* Motion Aids
Base extras:
#+BEGIN_SRC emacs-lisp
  (use-package avy
    :demand t
    :config (setq avy-background t
      		avy-keys '(
      			   ?a ?r ?s ?t ?g ?m ?n ?e ?i ?o
      			   ?z ?x ?c ?d ?v ?k ?h ?, ?.
      			   ?q ?w ?f ?p ?b ?j ?l ?u ?'))
    :general ("C-'" 'avy-goto-char-timer))

#+END_SRC

* Navigation
** Consult
#+BEGIN_SRC emacs-lisp
  (use-package embark-consult
    :after (embark consult))

  ;; Consult: Misc. enhanced commands
  (use-package consult
    ;; TODO consider using general here
    :bind (
      	 ("C-c M-x" . consult-mode-command)
      	 ("C-c h" . consult-history)
      	 ("C-c k" . consult-kmacro)
      	 ("C-c m" . consult-man)
      	 ("C-c i" . consult-info)
      	 ;; Drop-in replacements
      	 ("M-y"   . consult-yank-from-kill-ring)   ; orig. yank-pop
      	 ("M-g g" . consult-goto-line)

      	 ("C-x b" . consult-buffer)     ; orig. switch-to-buffer
      	 ("C-x r b" . consult-bookmark)            ;; orig. bookmark-jump
      	 ("C-x p b" . consult-project-buffer)      ;; orig. project-switch-to-buffer

      	 ;; M-g bindings in `goto-map'
      	 ("M-g e" . consult-compile-error)
      	 ("M-g f" . consult-flymake)               ;; Alternative: consult-flycheck
      	 ("M-g g" . consult-goto-line)             ;; orig. goto-line
      	 ("M-g M-g" . consult-goto-line)           ;; orig. goto-line
      	 ("M-g o" . consult-outline)               ;; Alternative: consult-org-heading
      	 ("M-g m" . consult-mark)
      	 ("M-g k" . consult-global-mark)
      	 ("M-g i" . consult-imenu)
      	 ("M-g I" . consult-imenu-multi)
      	 ;; M-s bindings in `search-map'
      	 ("M-s d" . consult-find)                  ;; Alternative: consult-fd
      	 ("M-s c" . consult-locate)
      	 ("M-s g" . consult-grep)
      	 ("M-s G" . consult-git-grep)
      	 ("M-s r" . consult-ripgrep)
      	 ("M-s l" . consult-line)
      	 ("M-s L" . consult-line-multi)
      	 ("M-s k" . consult-keep-lines)
      	 ("M-s u" . consult-focus-lines)
      	 ;; Isearch integration
      	 ("M-s e" . consult-isearch-history)
      	 :map isearch-mode-map
      	 ("M-e" . consult-isearch-history)         ;; orig. isearch-edit-string
      	 ("M-s e" . consult-isearch-history)       ;; orig. isearch-edit-string
      	 ("M-s l" . consult-line)                  ;; needed by consult-line to detect isearch
      	 ("M-s L" . consult-line-multi)            ;; needed by consult-line to detect isearch
      	 ;; Minibuffer history
      	 :map minibuffer-local-map
      	 ("M-s" . consult-history)                 ;; orig. next-matching-history-element

      	 )
    :config
    ;; Narrowing lets you restrict results to certain groups of candidates
    (setq consult-narrow-key "<")

    ;; set manual preview for result that will require a disk read
    (consult-customize
     consult-ripgrep consult-git-grep consult-grep
     consult-bookmark consult-recent-file consult-xref
     consult--source-bookmark consult--source-file-register
     consult--source-recent-file consult--source-project-recent-file
     ;; :preview-key '(:debounce 0.4 any) ;; Option 1: Delay preview
     :preview-key "M-.")            ;; Option 2: Manual preview
    )

  (use-package consult-project-extra
    :straight t
    :bind
    (("C-x p f" . consult-project-extra-find)
     ("C-x p o" . consult-project-extra-find-other-window)))

  (use-package consult-dir
    :after vertico
    :bind (("C-x C-d" . consult-dir)
           :map vertico-map
           ("C-x C-d" . consult-dir)
           ("C-x C-j" . consult-dir-jump-file)))

  (use-package embark
    :demand t
    :after avy
    :bind (("C-c a" . embark-act))        ; bind this to an easy key to hit
    :init
    ;; Add the option to run embark when using avy
    (defun bedrock/avy-action-embark (pt)
      (unwind-protect
      	(save-excursion
      	  (goto-char pt)
      	  (embark-act))
        (select-window
         (cdr (ring-ref avy-ring 0))))
      t)

    ;; After invoking avy-goto-char-timer, hit "." to run embark at the next
    ;; candidate you select
    (setf (alist-get ?. avy-dispatch-alist) 'bedrock/avy-action-embark))
#+END_SRC

** Minibuffer
#+BEGIN_SRC emacs-lisp  
  ;; Vertico: better vertical completion for minibuffer commands
  (use-package vertico
    :init
    ;; You'll want to make sure that e.g. fido-mode isn't enabled
    (vertico-mode))

  (use-package vertico-directory
    :straight nil
    :after vertico
    :bind (:map vertico-map
    	      ("C-j" . vertico-directory-enter)
    	      ("C-l" . vertico-directory-up)
    	      ("DEL" . vertico-directory-delete-char)
    	      ("M-DEL" . vertico-directory-delete-word)))

  ;; Marginalia: annotations for minibuffer
  (use-package marginalia
    :config
    (marginalia-mode))
#+END_SRC

** Completion
#+BEGIN_SRC emacs-lisp  
  ;; Popup completion-at-point
  (use-package corfu
    :straight (:files (:defaults "extensions/*"))
    :init
    (global-corfu-mode)
    :bind
    (:map corfu-map
      	("SPC" . corfu-insert-separator)
      	("C-n" . corfu-next)
      	("C-p" . corfu-previous)))

  ;; Part of corfu
  (use-package corfu-popupinfo
    :straight nil
    :after corfu
    :hook (corfu-mode . corfu-popupinfo-mode)
    :custom
    (corfu-popupinfo-delay '(0.25 . 0.1))
    (corfu-popupinfo-hide nil)
    :config
    (corfu-popupinfo-mode))

  ;; Make corfu popup come up in terminal overlay
  (use-package corfu-terminal
    :if (not (display-graphic-p))
    :config
    (corfu-terminal-mode))

  ;; Fancy completion-at-point functions; there's too much in the cape package to
  ;; configure here; dive in when you're comfortable!
  (use-package cape
    :init
    (add-to-list 'completion-at-point-functions #'cape-dabbrev)
    (add-to-list 'completion-at-point-functions #'cape-file))

  ;; Pretty icons for corfu
  (use-package kind-icon
    :if (display-graphic-p)
    :after corfu
    :config
    (add-to-list 'corfu-margin-formatters #'kind-icon-margin-formatter))

  (use-package eshell
    :init
    (defun bedrock/setup-eshell ()
      ;; Something funny is going on with how Eshell sets up its keymaps; this is
      ;; a work-around to make C-r bound in the keymap
      (keymap-set eshell-mode-map "C-r" 'consult-history))
    :hook ((eshell-mode . bedrock/setup-eshell)))

  ;; Orderless: powerful completion style
  (use-package orderless
    :config
    (setq completion-styles '(orderless)))
#+END_SRC

* Filesystem
** Dired
~dired~ is basically a file explorer.
#+BEGIN_SRC emacs-lisp
  (use-package dired
    :straight nil
    :defer t
    :general
    (my-leader-def "d" 'dired)
    (dired-mode-map "c" 'dired-do-copy)
    (dired-mode-map "r" 'dired-do-rename)
    (dired-mode-map "." 'hydra-dired/body)
    :hydra
    (hydra-dired (:hint nil :color pink)
                 "
  _+_ mkdir          _v_iew           _m_ark             _(_ details        _i_nsert-subdir    wdired
  _c_opy             _O_ view other   _U_nmark all       _)_ omit-mode      _$_ hide-subdir    C-x C-q : edit
  _D_elete           _o_pen other     _u_nmark           _l_ redisplay      _w_ kill-subdir    C-c C-c : commit
  _r_ename           _M_ chmod        _t_oggle           _g_ revert buf     _e_ ediff          C-c ESC : abort
  _Y_ rel symlink    _G_ chgrp        _E_xtension mark   _s_ort             _=_ pdiff
  _S_ymlink          ^ ^              _F_ind marked      _._ toggle hydra   \\ flyspell
  _R_sync            ^ ^              ^ ^                ^ ^                _?_ summary
  _z_ compress-file  _A_ find regexp
  _Z_ compress       _Q_ repl regexp

  T - tag prefix
  "
                 ("\\" dired-do-ispell)
                 ("(" dired-hide-details-mode)
                 (")" dired-omit-mode)
                 ("+" dired-create-directory)
                 ("=" diredp-ediff)         ;; smart diff
                 ("?" dired-summary)
                 ("$" diredp-hide-subdir-nomove)
                 ("A" dired-do-find-regexp)
                 ("c" dired-do-copy)        ;; Copy all marked files
                 ("D" dired-do-delete)
                 ("E" dired-mark-extension)
                 ("e" dired-ediff-files)
                 ("F" dired-do-find-marked-files)
                 ("G" dired-do-chgrp)
                 ("g" revert-buffer)        ;; read all directories again (refresh)
                 ("i" dired-maybe-insert-subdir)
                 ("l" dired-do-redisplay)   ;; relist the marked or singel directory
                 ("M" dired-do-chmod)
                 ("m" dired-mark)
                 ("O" dired-display-file)
                 ("o" dired-find-file-other-window)
                 ("Q" dired-do-find-regexp-and-replace)
                 ("r" dired-do-rename)
                 ("R" dired-do-rsynch)
                 ("S" dired-do-symlink)
                 ("s" dired-sort-toggle-or-edit)
                 ("t" dired-toggle-marks)
                 ("U" dired-unmark-all-marks)
                 ("u" dired-unmark)
                 ("v" dired-view-file)      ;; q to exit, s to search, = gets line #
                 ("w" dired-kill-subdir)
                 ("Y" dired-do-relsymlink)
                 ("z" diredp-compress-this-file)
                 ("Z" dired-do-compress)
                 ("q" nil)
                 ("." nil :color blue)))

  ;; Colourful columns.
  (use-package diredfl
    :after dired
    :config
    (diredfl-global-mode +1))

  (use-package dired-git-info
    :config
    (setq dgi-auto-hide-details-p nil)
    (add-hook 'dired-after-readin-hook 'dired-git-info-auto-enable))

  (use-package all-the-icons-dired
    :after all-the-icons
    :config
    (add-hook 'dired-mode-hook 'all-the-icons-dired-mode))
#+END_SRC
* Editting
** Undo
[[https://github.com/emacsmirror/undo-fu][~undo-fu~]] improves the default undo experience.
#+BEGIN_SRC emacs-lisp
  (use-package undo-fu
    :general
    ("C-z" 'undo-fu-only-undo)
    ("C-S-z" 'undo-fu-only-redo))
#+END_SRC

[[https://github.com/casouri/vundo][~vundo~]] displays a nice braching undo tree built on top of the default undo system.
#+BEGIN_SRC emacs-lisp
  (use-package vundo
    :config
    ;; use a nicer unicode font to display the tree
    (setq vundo-glyph-alist vundo-unicode-symbols))
#+END_SRC


** Rectangles
This is a hydra for working with the ~rectangle~ commands.

TODO: I should understand how this works better.

#+BEGIN_SRC emacs-lisp
  (my-leader-def "R" '(hydra-rectangle/body :wk "rectangle"))
  (defhydra hydra-rectangle (:body-pre (rectangle-mark-mode 1)
                                       :color pink
                                       :hint nil
                                       :post (deactivate-mark))
    "
      ^_i_^       _w_ copy      _O_pen       _N_umber-lines
    _n_   _o_     _y_ank        _t_ype       _E_xchange-point
      ^_e_^       _d_ kill      _c_lear      _r_eset-region-mark
    ^^^^          _u_ndo        _q_uit       ^ ^
    "
    ("i" rectangle-previous-line)
    ("e" rectangle-next-line)
    ("n" rectangle-backward-char)
    ("o" rectangle-forward-char)
    ("d" kill-rectangle)                    ;; C-x r k
    ("y" yank-rectangle)                    ;; C-x r y
    ("w" copy-rectangle-as-kill)            ;; C-x r M-w
    ("O" open-rectangle)                    ;; C-x r o
    ("t" string-rectangle)                  ;; C-x r t
    ("c" clear-rectangle)                   ;; C-x r c
    ("E" rectangle-exchange-point-and-mark) ;; C-x C-x
    ("N" rectangle-number-lines)            ;; C-x r N
    ("r" (if (region-active-p)
             (deactivate-mark)
           (rectangle-mark-mode 1)))
    ("u" undo nil)
    ("q" nil))
#+END_SRC

** Whitespace Removal
[[https://github.com/lewang/ws-butler][~ws-butler~]] automatically removes trailing whitespace from lines that have been editted.

#+BEGIN_SRC emacs-lisp
  (use-package ws-butler
    :config
    (ws-butler-global-mode))
#+END_SRC


** Move to beginning of line
This snippet provides smarter moving to the beginning of the line. Copied from [[https://emacsredux.com/blog/2013/05/22/smarter-navigation-to-the-beginning-of-a-line/][EmacsRedux]].
#+BEGIN_SRC emacs-lisp
  (defun smarter-move-beginning-of-line (arg)
    "Move point back to indentation of beginning of line.

    Move point to the first non-whitespace character on this line.
    If point is already there, move to the beginning of the line.
    Effectively toggle between the first non-whitespace character and
    the beginning of the line.

    If ARG is not nil or 1, move forward ARG - 1 lines first.  If
    point reaches the beginning or end of the buffer, stop there."
    (interactive "^p")
    (setq arg (or arg 1))

    ;; Move lines first
    (when (/= arg 1)
      (let ((line-move-visual nil))
        (forward-line (1- arg))))

    (let ((orig-point (point)))
      (back-to-indentation)
      (when (= orig-point (point))
        (move-beginning-of-line 1))))

  ;; remap C-a to `smarter-move-beginning-of-line'
  (general-define-key "C-a" 'smarter-move-beginning-of-line)
#+END_SRC

* Window Management

[[https://github.com/abo-abo/ace-window][~ace-window~]] allows for easy switching between windows within a frame, splitting windows and moving and
copying windows.
#+BEGIN_SRC emacs-lisp
  (use-package ace-window
    :general
    ("C-x o" 'ace-window)
    :config
    (setq aw-keys '(?a ?r ?s ?t ?n ?e ?i ?o)))
#+END_SRC

[[https://github.com/dimitri/switch-window][~switch-window~]] allows for easy switching between windows within a frame. It's slightly better than
~ace-window~ for that basic task as the labels for the windows are larger. However, ~ace-window~ is
worth keeping around for other functionality.
#+BEGIN_SRC emacs-lisp
  (use-package switch-window
    :general
    ("M-o" 'switch-window)
    :config
    (setq switch-window-shortcut-style 'qwerty))
#+END_SRC


[[https://www.gnu.org/software/emacs/manual/html_node/emacs/Window-Convenience.html#index-winner_002dmode][~winner-mode~]] tracks changes in window configuration for a frame so that they can be undone or
redone.
#+BEGIN_SRC emacs-lisp
  (use-package winner
    :commands winner-mode
    :init (winner-mode t))
#+END_SRC

These are various functions for manipulating window size.
#+BEGIN_SRC emacs-lisp
  (defun hydra-move-splitter-left (delta)
    "Move window splitter left."
    (interactive "p")
    (let ((windmove-wrap-around nil))
      (if (windmove-find-other-window 'right)
          (shrink-window-horizontally delta)
        (enlarge-window-horizontally delta))))

  (defun hydra-move-splitter-right (delta)
    "Move window splitter right."
    (interactive "p")
    (let ((windmove-wrap-around nil))
      (if (windmove-find-other-window 'right)
          (enlarge-window-horizontally delta)
        (shrink-window-horizontally delta))))

  (defun hydra-move-splitter-up (delta)
    "Move window splitter up."
    (interactive "p")
    (let ((windmove-wrap-around nil))
      (if (windmove-find-other-window 'up)
          (enlarge-window delta)
        (shrink-window delta))))

  (defun hydra-move-splitter-down (delta)
    "Move window splitter down."
    (interactive "p")
    (let ((windmove-wrap-around nil))
      (if (windmove-find-other-window 'up)
          (shrink-window delta)
        (enlarge-window delta))))
#+END_SRC

Now we've got a hydra to make the various window management functions easily accessible.
#+BEGIN_SRC emacs-lisp
  (defhydra hydra-window-delux (:hint nil)
    "
      ^Movement^        ^Split^          ^Switch^            ^Resize^
      -------------------------------------------------------------------
      _n_ ←             _r_ight          _b_uffer            _l_ X←
      _e_ ↓             _d_own           _f_ind files        _u_ X↓
      _i_ ↑             _z_ undo         _a_ce 1             _y_ X↑
      _o_ →             _Z_ reset        _s_wap              _'_ X→
      _F_ollow          _D_lt Other      ^ ^                 _m_aximize
      _q_ quit          _O_nly this      _c_lose             _=_ balance
      "
    ;; Movement
    ("n" windmove-left )
    ("e" windmove-down )
    ("i" windmove-up )
    ("o" windmove-right )
    ("F" follow-mode)

    ;; Resize
    ("l" hydra-move-splitter-left)
    ("u" hydra-move-splitter-down)
    ("y" hydra-move-splitter-up)
    ("'" hydra-move-splitter-right)
    ("m" ace-maximize-window)
    ("=" balance-windows)

    ;; Split
    ("r" (lambda ()
           (interactive)
           (split-window-right)
           (windmove-right)))
    ("d" (lambda ()
           (interactive)
           (split-window-below)
           (windmove-down)))
    ("z" (progn
           (winner-undo)
           (setq this-command 'winner-undo)))
    ("Z" winner-redo)
    ("D" (lambda ()
           (interactive)
           (ace-window 16)
           (add-hook 'ace-window-end-once-hook
                     'hydra-window/body)))
    ("O" delete-other-windows)

    ;; Switch
    ("b" consult-buffer)
    ("f" find-files)
    ("a" (lambda ()
           (interactive)
           (ace-window 1)
           (add-hook 'ace-window-end-once-hook
                     'hydra-window/body)))
    ("s" (lambda ()
           (interactive)
           (ace-window 4)
           (add-hook 'ace-window-end-once-hook
                     'hydra-window/body)))
    ("c" delete-window)

    ("q" nil))
  (my-leader-def
    "w" '(hydra-window-delux/body :wk "Window Management"))
#+END_SRC

* Software Development
** Treesitter Setup
#+BEGIN_SRC emacs-lisp
  (use-package emacs
    :config
    ;; Treesitter config
    (setq treesit-language-source-alist
  	'((bash "https://github.com/tree-sitter/tree-sitter-bash")
  	  (cmake "https://github.com/uyha/tree-sitter-cmake")
  	  (css "https://github.com/tree-sitter/tree-sitter-css")
  	  (elisp "https://github.com/Wilfred/tree-sitter-elisp")
  	  (go "https://github.com/tree-sitter/tree-sitter-go")
  	  (gomod "https://github.com/camdencheek/tree-sitter-go-mod")
  	  (dockerfile "https://github.com/camdencheek/tree-sitter-dockerfile")
  	  (html "https://github.com/tree-sitter/tree-sitter-html")
  	  (javascript "https://github.com/tree-sitter/tree-sitter-javascript" "master" "src")
  	  (json "https://github.com/tree-sitter/tree-sitter-json")
  	  (make "https://github.com/alemuller/tree-sitter-make")
  	  (markdown "https://github.com/ikatyang/tree-sitter-markdown")
  	  (python "https://github.com/tree-sitter/tree-sitter-python")
  	  (toml "https://github.com/tree-sitter/tree-sitter-toml")
  	  (tsx "https://github.com/tree-sitter/tree-sitter-typescript" "master" "tsx/src")
  	  (typescript "https://github.com/tree-sitter/tree-sitter-typescript" "master" "typescript/src")
  	  (yaml "https://github.com/ikatyang/tree-sitter-yaml")))
    ;; Tell Emacs to prefer the treesitter mode
    ;; You'll want to run the command `M-x treesit-install-language-grammar' before editing.
    (setq major-mode-remap-alist
  	'((yaml-mode . yaml-ts-mode)
  	  (bash-mode . bash-ts-mode)
  	  (go-mode . go-ts-mode)
  	  (js2-mode . js-ts-mode)
  	  (typescript-mode . typescript-ts-mode)
  	  (json-mode . json-ts-mode)
  	  (css-mode . css-ts-mode)
  	  (python-mode . python-ts-mode)))
    :hook
    ;; Auto parenthesis matching
    ((prog-mode . electric-pair-mode)))

#+END_SRC
** Git
#+BEGIN_SRC emacs-lisp  
  (use-package magit
    :general
    ("C-x g" 'magit-status)
    (my-leader-def
      "g" 'hydra-my-git-menu/body)
    :config
    ;; This sets Magit to use the fullframe
    ;;(setq magit-display-buffer-function #'magit-display-buffer-fullframe-status-v1)
    (defun my/magit-yank-branch-name ()
      "Show the current branch in the echo-area and add it to the `kill-ring'."
      (interactive)
      (let ((branch (magit-get-current-branch)))
        (if branch
            (progn (kill-new branch)
                   (message "%s" branch))
          (user-error "There is not current branch")))))
#+END_SRC

[[https://github.com/dandavison/magit-delta][~magit-delta~]] enables improved diffs for Magit using [[https://github.com/dandavison/delta][delta]].

I've disabled this for now since it seemed a bit slow.
#+begin_src emacs-lisp
  (use-package magit-delta
    :disabled
    :hook (magit-mode . magit-delta-mode))
#+end_src
[[https://github.com/emacsmirror/git-timemachine][~git-timemachine~]] allows you to walk through Git revisions of a file to view changes over time.
#+BEGIN_SRC emacs-lisp
  (use-package git-timemachine
    :defer t)
#+END_SRC

[[https://github.com/redguardtoo/vc-msg][~vc-msg~]] shows a popup containing the commit message that last affected the current line.
#+BEGIN_SRC emacs-lisp
  (use-package vc-msg
    :defer t)
#+END_SRC

[[https://github.com/dgutov/diff-hl][~diff-hl~]] shows icons on the buffer fringe for lines that have been added, removed or
modified.
#+BEGIN_SRC emacs-lisp
  (use-package diff-hl
    :hook (magit-post-refresh . diff-hl-magit-post-refresh)
    :config
    (diff-hl-flydiff-mode)
    (global-diff-hl-mode))
    #+END_SRC

[[https://github.com/rmuslimov/browse-at-remote][~browse-at-remote~]] allows for quick jumping to the relevant Github (or whatever) page corresponding
to the current file.
#+BEGIN_SRC emacs-lisp
  (use-package browse-at-remote)
 #+END_SRC

A nice Hydra menu to make things more accessible.
  #+BEGIN_SRC emacs-lisp
    (defhydra hydra-my-git-menu (:color blue
                                        :hint nil)
      "
              ^Navigate^        ^Action^               ^Info^
              ^^^^^^^^^^^^---------------------------------------------------
              _n_: next hunk    _s_: stage hunk        _d_: diff
              _p_: prev hunk    _S_: stage file        _c_: show commit
              ^ ^               _U_: unstage file      _g_: magit status
              ^ ^               ^ ^                    _t_: git timemachine
              _r_: browse at remote                  _b_: yank branch name
              "
      ("n" diff-hl-next-hunk :color red)
      ("p" diff-hl-previous-hunk :color red)
      ("s" diff-hl-stage-current-hunk)
      ("S" magit-stage-file)
      ("U" magit-unstage-file)
      ("c" vc-msg-show :color red)
      ("g" magit-status :exit t)
      ("d" magit-diff-buffer-file)
      ("t" git-timemachine :exit t)
      ("b" my/magit-yank-branch-name :exit t)
      ("r" browse-at-remote)
      ("q" nil :exit t))

    (defhydra hydra-my-git-timemachine-menu (:color blue)
      ("s" git-timemachine "start")
      ("j" git-timemachine-show-next-revision "next revision")
      ("k" git-timemachine-show-previous-revision "prev revision")
      ("c" git-timemachine-show-current-revision "curr revision")
      ("<ESC>" git-timemachine-show-current-revision "quit" :exit t))
#+END_SRC


** Flymake
#+BEGIN_SRC emacs-lisp
  (use-package flymake
    ;; TODO include this in project hydra
    :bind (("H-e" . flymake-show-project-diagnostics)))
#+END_SRC

** LSP Servers

#+BEGIN_SRC emacs-lisp
  (use-package eglot
    :straight nil
    :hook
    ((go-ts-mode . eglot-ensure)
     (python-ts-mode . eglot-ensure))
    :custom
    (eglot-send-changes-idle-time 0.1)
    ;; activate Eglot in referenced non-project files
    (eglot-extend-to-xref t)
    :config
    ;; massive perf boost---don't log every event
    (fset #'jsonrpc--log-event #'ignore))
#+END_SRC

** Particular Programming modes
#+BEGIN_SRC emacs-lisp  
  (use-package markdown-mode
    :hook ((markdown-mode . visual-line-mode)))

  (use-package yaml-mode)

  (use-package json-mode)

  (use-package go-ts-mode)

  (use-package sh-script
    :hook (sh-mode . flymake-mode))

  (use-package terraform-mode)
#+END_SRC

These packages need to be installed in the Python environment too.
#+BEGIN_SRC sh
 pip install "python-lsp-server[all]" pylsp-mypy pylsp-rope python-lsp-ruff python-lsp-black
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (use-package pyvenv)
#+END_SRC

* Yasnippets
#+BEGIN_SRC emacs-lisp
  (use-package yasnippet
    :config
    (yas-global-mode +1)
    (setq yas-snippet-dirs (append yas-snippet-dirs
  				 '("~/.emacs.d/snippets/"))))

  (use-package yasnippet-snippets
    :after yasnippet)
#+END_SRC

** Snippets
These are various snippets for use with Yasnippet.
#+BEGIN_SRC :tangle "~/.emacs.d/snippets/go-mode/ifen" :eval no :mkdirp yes
# -*- mode: snippet -*-
# name: if error nil
# key: ifen
# --
if err != nil {
  $1
}
#+END_SRC

* Org
See helpful examples at:
- http://doc.norang.ca/org-mode.html

** Setup
#+BEGIN_SRC emacs-lisp
  (use-package org
    :general
    ("C-c l" 'org-store-link)
    ;; This conflicts with Avy
    (org-mode-map "C-'" nil)

    :config
    (setq org-agenda-files my/org-agenda-files
          org-directory my/org-dir
          org-tags-column 75
          org-log-into-drawer t ;; hide the log state change history a bit better
          org-deadline-warning-days 7
          org-agenda-skip-scheduled-if-deadline-is-shown t
          org-habit-graph-column 65
          org-duration-format 'h:mm ;; show hours at max, not days
          org-agenda-compact-blocks t
          org-cycle-separator-lines 0
          ;; hide empty agenda sections
          org-agenda-clockreport-parameter-plist '(:stepskip0 t :link t :maxlevel 2 :fileskip0 t)
          ;; default show today
          org-agenda-span 'day
          org-agenda-start-day "-0d"
          org-agenda-start-on-weekday 1
          org-agenda-custom-commands
          '(("d" "Done tasks" tags "/DONE|CANCELED")
            ("g" "Plan Today"
             ((agenda "" ((org-agenda-span 'day)))
              (org-agenda-skip-function '(org-agenda-skip-deadline-if-not-today))
              (org-agenda-entry-types '(:deadline))
              (org-agenda-overriding-header "Today's Deadlines "))))
          ))

#+END_SRC

[[https://github.com/minad/org-modern][~org-modern~]] gives ~org-mode~ a more modern style.
#+begin_src emacs-lisp
  (use-package org-modern
    :config
    (global-org-modern-mode))
#+end_src

** Task States
#+BEGIN_SRC emacs-lisp
  (setq org-todo-keywords
      '((sequence "TODO(t)"
                  "PLANNING(p)"
                  "IN-PROGRESS(i@/!)"
                  "VERIFYING(v!)"
                  "BLOCKED(b@)"
                  "WAITING(w@)"
                  "|"
                  "DONE(d!)"
                  "CANCELLED(c@)"
                  "OBE(o@)"
                  "WONT-DO(n@/!)")))
#+END_SRC

** Tags
#+BEGIN_SRC emacs-lisp
  (setq org-tag-alist '(
                        ;; Task types
                        (:startgroup . nil)
                        ("email" . ?e)
                        ("design" . ?d)
                        ("implementation" . ?M)
                        ("improvement" . ?r)
                        ("investigation" . ?v)
                        (:endgroup . nil)

                        ;; Meeting types
                        (:startgroup . nil)
                        ("weekly_setup" . ?S)
                        ("weekly_wrap_up" . ?W)
                        ("1_to_1" . ?1)
                        (:endgroup . nil)

                        ;; Code TODOs tags
                        ("questionable_code" . ?q)
                        ("refactor" . ?F)

                        ;; Special tags
                        ("CRITICAL" . ?c)

                        ;; Meeting tags
                        ("meeting" . ?m)

                        ;; Work Log Tags
                        ("accomplishment" . ?A)
                        ))
#+END_SRC

** Export Options
[[https://github.com/hniksic/emacs-htmlize][~htmlize~]] converts a buffer to HTML with nice syntax highlighting.
#+BEGIN_SRC emacs-lisp
  (use-package htmlize
    :defer t)
#+END_SRC

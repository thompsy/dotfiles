#+TITLE: emacs.org
#+PROPERTY: header-args:emacs-lisp :tangle ~/.emacs.d/init.el :results silent :exports code

* emacs.org
** What is this?
This is my emacs configuration in =org-mode=. To output the source code run ~org-babel-tangle~
(typically ~C-c~ ~C-v~ ~t~). This will output the relevant files into ~~/.emacs.d/~ where Emacs will pick
them up.

Many (most!) things in this file have been inspired by others making their configuration
available. A few places that I've found particularly useful include:
- [[https://github.com/kwpav/dotfiles/blob/master/emacs.org][kwpav's config]]
- [[http://pages.sachachua.com/.emacs.d/Sacha.html][Sacha Chua's config]]
- [[https://github.com/TheBB/dotemacs][TheBB's config]]
- [[https://github.com/jwiegley/dot-emacs][jwiegly's config]]
- [[https://github.com/syl20bnr/spacemacs][Spacemacs]]
- [[https://github.com/hlissner/doom-emacs][Doom Emacs]]
- [[https://github.com/MatthewZMD/.emacs.d#org0f80f62][M-EMACS]]
- [[https://github.com/ianpan870102/yay-evil-emacs/blob/master/config.org][yay-evil]]
- [[https://framagit.org/steckerhalter/steckemacs.el/-/tree/master][steckemacs]]

* TODO
- rationalise Hydra config across packages
- rationalise General config across packages
- understand ~:defer~ and ~:ensure~ and remove where appropriate
  - see https://emacs.stackexchange.com/questions/41329/when-to-use-defer-in-use-package
- consider having Emacs manage system packages that it depends on so that they can be auto-installed
  - something like this: ~(use-package use-package-ensure-system-package)~
  - see https://github.com/jwiegley/use-package#use-package-ensure-system-package
- explore prescient.el to sort company-mode suggestions
- try other modelines in due course
- have all hydras use q for quit
- use ~:after~ to specify any dependencies
* Emacs
** Local
These are various, installation specific settings that might differ across machines, some of which I
don't want to commit to Git.

#+BEGIN_SRC emacs-lisp :tangle "~/.emacs.d/local.el" :eval no
  (provide 'local-setup)

  (setq user-full-name "Andrew Thompson"
        user-mail-address "github@downthewire.co.uk")

  (defconst my/org-dir
    "~/notebook/")

  (defconst my/org-agenda-files
    (list
     my/org-dir
     (concat my/org-dir "journal")))
#+END_SRC

** Early Init
The ~early-init.el~ file is called very early in the initialisation process, so this is a good point
to disable ~package.el~ in favour of ~straight.el~.
#+BEGIN_SRC emacs-lisp :tangle "~/.emacs.d/early-init.el" :eval no
(setq package-enable-at-startup nil)
#+END_SRC

** Preamble
Some initial comment blurb.
#+BEGIN_SRC emacs-lisp
  ;;; init.el --- Initialization file for Emacs
  ;;; Commentary: Emacs Startup File --- initialization for Emacs
  ;;; Code:
#+END_SRC

Load some local setup. As noted above, this is generally installation specific, so its easiest to
keep it in a separate file.
#+BEGIN_SRC emacs-lisp
(require 'local-setup "~/.emacs.d/local.el")
#+END_SRC

Determine the operating system to tailor aspects of the config.
#+BEGIN_SRC emacs-lisp
(setq *is-a-mac* (eq system-type 'darwin)
      *is-linux* (eq system-type 'gnu/linux)
      *is-windows* (eq system-type 'windows-nt))
#+END_SRC

** Straight Package Manager
Setup the [[https://github.com/radian-software/straight.el][~straight.el~]] package manager.
#+BEGIN_SRC emacs-lisp
  (setq straight-repository-branch "develop")

  (defvar bootstrap-version)
  (let ((bootstrap-file
         (expand-file-name "straight/repos/straight.el/bootstrap.el" user-emacs-directory))
        (bootstrap-version 5))
    (unless (file-exists-p bootstrap-file)
      (with-current-buffer
          (url-retrieve-synchronously
           "https://raw.githubusercontent.com/raxod502/straight.el/develop/install.el"
           'silent 'inhibit-cookies)
        (goto-char (point-max))
        (eval-print-last-sexp)))
    (load bootstrap-file nil 'nomessage))
#+END_SRC

From the straight docs:
#+BEGIN_QUOTE
By setting the variable straight-cache-autoloads to a non-nil value, you can cause straight.el to
cache the autoloads of all used packages in a single file on disk, and load them from there instead
of from the individual package files if they are still up to date. This reduces the number of disk
IO operations during startup from O(number of packages) to O(1), so it should improve
performance. No other configuration should be necessary to make this work; however, you may wish to
call straight-prune-build occasionally, since otherwise this cache file may grow quite large over
time.
#+END_QUOTE
#+BEGIN_SRC emacs-lisp
  (setq straight-cache-autoloads t)
#+END_SRC

In addition:
#+BEGIN_QUOTE
You may customize straight-use-package-by-default to make it so that :straight t is assumed unless
you explicitly override it with :straight nil.
#+END_QUOTE

#+BEGIN_SRC emacs-lisp
  (setq straight-use-package-by-default t)
#+END_SRC

Install [[https://github.com/jwiegley/use-package][~use-package~]] for easily installing other packages.
#+BEGIN_SRC emacs-lisp
  ;; Install use-package to use with straight.el
  (straight-use-package 'use-package)
#+END_SRC

I don't want to use the built-in version of org-mode since it's usually pretty old. Instead I want
straight to pull down the latest version. To avoid the built-in version getting loaded we need to
explicitly load it with straight early in the init process. See more details in the [[https://github.com/radian-software/straight.el#the-wrong-version-of-my-package-was-loaded][README.md]].
#+BEGIN_SRC emacs-lisp
  (straight-use-package 'org)
#+END_SRC

** Core Configuration
Diminish hides or abbreviates the mode line displays of minor-modes. It basically de-clutters the
mode line, keeping things minimal and focused.
#+BEGIN_SRC emacs-lisp
  (use-package diminish)
#+END_SRC

The [[https://github.com/emacsmirror/gcmh][~gcmh~]] (Garbage Collector Magic Hack) package updates Emacs's GC strategy to minimise interference
with user activity.
#+BEGIN_SRC emacs-lisp
  (use-package gcmh
    :hook (after-init . gcmh-mode))
#+END_SRC

Emacs Start-up Profiler, [[https://github.com/jschaf/esup][esup]], enables profiling your Emacs startup time without leaving emacs.
#+BEGIN_SRC emacs-lisp
  ;; Emacs Start-up Profiler
  (use-package esup
    ;; This config is needed to fix a minor bug: https://github.com/jschaf/esup/issues/54
    :config (setq esup-depth 0)
    :commands (esup))
#+END_SRC

Allow Emacs to read larger chunks of data from subprocesses. Things like ~lsp-mode~ can generate
responses from 800k to 3M, so the default of 4k is too small.
#+BEGIN_SRC emacs-lisp
  (setq read-process-output-max (* 1024 1024 3)) ;; 3mb
#+END_SRC

A few miscellaneous settings. Note that ~emacs~ is not really a package strictly speaking which is why
we include ~:straight nil~ so that our package manager doesn't try to fetch the source.
#+BEGIN_SRC emacs-lisp
  (use-package emacs
    :straight nil
    :init
    ;; answer with y/n instead of typing out yes/no
    (defalias 'yes-or-no-p 'y-or-n-p)
    :config
    (setq indent-tabs-mode nil
          tab-width 4
          show-trailing-whitespace t
          fill-column 100)
    (setq-default indent-tabs-mode nil
                  fill-column 100)
    :custom
    ;; load new source files instead of stale elisp bytecode
    (load-prefer-newer t)
    ;; allow emacs to be any size, removes black bars
    (frame-resize-pixelwise t))
#+END_SRC

It's useful to have buffers auto-revert when files on disk change especially when using Git branches
a lot!
#+BEGIN_SRC emacs-lisp
  (use-package autorevert
    :straight nil
    :custom
    (global-revert-check-vc-info t)
    :config
    (global-auto-revert-mode +1))
#+END_SRC

Use UTF-8 everywhere.
#+BEGIN_SRC emacs-lisp
  (use-package mule
    :straight nil
    :config
    (prefer-coding-system 'utf-8-unix)
    (set-default-coding-systems 'utf-8-unix)
    (set-language-environment 'utf-8)
    (set-terminal-coding-system 'utf-8-unix)
    (setq locale-coding-system 'utf-8-unix)
    (set-selection-coding-system 'utf-8-unix))
#+END_SRC

Setup some basic file hygiene. Keep some backup files around, but keep them out of sight.
#+BEGIN_SRC emacs-lisp
  (use-package files
    :straight nil
    :config
    (setq
     backup-by-copying t
     backup-directory-alist '((".*" . "~/.emacs.d/backups/"))
     delete-old-versions t
     kept-new-versions 6
     kept-old-versions 2
     version-control t
     vc-make-backup-files t
     recentf-max-menu-items 25
     recentf-max-saved-items 500))
#+END_SRC

Use the system keyboard when killing and yanking.
#+BEGIN_SRC emacs-lisp
  (use-package simple
    :straight nil
    :custom
    ;; killing and yanking uses the system clipboard
    (save-interprogram-paste-before-kill t))
#+END_SRC

~so-long~ is a built-in mode which deals with very long lines, like those in minified Javascript for
example.
#+BEGIN_SRC emacs-lisp
  (use-package so-long
    :straight nil
    :config
    (global-so-long-mode +1))
#+END_SRC

[[https://github.com/emacs-mirror/emacs/blob/master/lisp/saveplace.el][~saveplace~]] jumps back to
the last when later visiting a file. This is handy to pick up where you left off.
#+BEGIN_SRC emacs-lisp
  (use-package saveplace
    :straight nil
    :config
    (save-place-mode +1))
#+END_SRC

[[https://github.com/emacscollective/no-littering][~no-littering~]] keeps configuration files and
other persistent data under ~user-emacs-directory~ rather than spamming them in inconsistent places.
#+BEGIN_SRC emacs-lisp
  (use-package no-littering
    :init
    (setq no-littering-etc-directory
          (expand-file-name "etc/" user-emacs-directory))
    (setq no-littering-var-directory
          (expand-file-name "var/" user-emacs-directory)))
#+END_SRC

Use a separate custom file to remove auto-generated code from ~init.el~. This should be loaded prior
to any themes so that they confirmation code gets stored in ~custom.el~.
#+BEGIN_SRC emacs-lisp
  (use-package cus-edit
    :straight nil
    :custom
    (custom-file (expand-file-name "custom.el" user-emacs-directory))
    :config
    (if (file-exists-p custom-file)
        (load-file custom-file)))
#+END_SRC

** OS Specific
Map some keys on MacOS.
#+BEGIN_SRC emacs-lisp
  (use-package emacs
    :straight nil
    :when *is-a-mac*
    :config
    (setq mac-command-modifier 'meta     ;; Mac atl/option to Control
          mac-option-modifier 'control)  ;; Mac command to Meta
    (add-to-list 'default-frame-alist '(ns-transparent-titlebar . t))
    (add-to-list 'default-frame-alist '(ns-appearance . dark))
    (set-fontset-font t 'symbol (font-spec :family "Apple Symbols") nil 'prepend)
    (set-fontset-font t 'symbol (font-spec :family "Apple Color Emoji") nil 'prepend))
#+END_SRC

** Aesthetics

Turn off a bunch of frame related functionality for a more minimal experience.
#+BEGIN_SRC emacs-lisp
  (use-package frame
    :straight nil
    :config
    (blink-cursor-mode -1)
    (setq initial-scratch-message ""
          inhibit-startup-message t
          visible-bell nil
          ring-bell-function 'ignore
          initial-frame-alist
          '((menu-bar-lines . 0)
            (tool-bar-lines . 0)))
    (scroll-bar-mode 0)
    (tool-bar-mode 0)
    (menu-bar-mode 0)
    (global-hl-line-mode 1))
#+END_SRC

[[https://draculatheme.com/emacs][Dracula]] is a nice theme that's available for lots of apps.
#+BEGIN_SRC emacs-lisp
  (use-package dracula-theme
    :config
    (load-theme 'dracula))

  ;; TODO this could live somewhere more tidy...
  (add-to-list 'default-frame-alist '(font . "Fira Code-14"))
#+END_SRC

[[https://github.com/domtronn/all-the-icons.el][~all-the-icons.el~]] is a nice utility package that collects various icon fonts and makes them
available to Emacs.
#+BEGIN_SRC emacs-lisp
  (use-package all-the-icons
    :defer t)
#+END_SRC

[[https://github.com/seagle0128/doom-modeline][~doom-modeline~]] is a fancy, fast and minimal mode-line.
#+BEGIN_SRC emacs-lisp
  (use-package doom-modeline
    :demand t
    :preface
    (defun my-doom-modeline-setup ()
      (column-number-mode +1)
      (doom-modeline-mode +1))
    :init (my-doom-modeline-setup)
    :config
    (setq doom-modeline-height 1)
    (set-face-attribute 'mode-line nil :height 150)
    (set-face-attribute 'mode-line-inactive nil :height 150)
    :custom
    (doom-modeline-vcs-max-length 50)
    (doom-modeline-buffer-file-name-style 'truncate-upto-project))
#+END_SRC

** Keybindings
[[https://github.com/noctuid/general.el][~general.el~]] provides a convenient method for binding
keys. It also integrates well with ~use-package~. In particular, this allows us to easily setup a
global leader key, ~my-leader-def~ and chain bindings from that.
#+BEGIN_SRC emacs-lisp
  (use-package general
    :demand t
    :custom
    (general-override-states '(insert emacs hybrid normal visual motion operator replace))
    :config
    (general-define-key
     "C-w" 'backward-kill-word
     "C-c C-k" 'kill-region
     "C-x C-k" 'kill-region
     "C-x C-b" 'ibuffer
     ;; C-z defaults to suspend-frame which isn't very useful
     "C-z" 'undo
     "M-s" 'highlight-symbol-at-point
     "M-c" 'hi-lock-mode
     "M-z" 'pop-global-mark)

    ;; Make general's keybindings take precedence over keys bound to other minor mode keymaps.
    (general-override-mode)

    ;; We need to call this so that we can allocate C-t as a prefix key. See
    ;; https://github.com/noctuid/general.el#automatic-key-unbinding for details.
    (general-auto-unbind-keys)
    ;; Create a definer where most of my commands will live under
    (general-create-definer my-leader-def
      :prefix "C-t")
    ;; Setup some initial bindings.
    ;; TODO some of these should probably live elsewhere
    (my-leader-def
      "a" 'org-agenda
      "b" '(:ignore t :wk "bookmarks")
      "bs" 'bookmark-set
      "bl" 'helm-bookmarks
      ;; quit / restart
      "q" '(:ignore t :wk "quit / restart")
      "qq" 'save-buffers-kill-terminal
      "qQ" 'save-buffers-kill-emacs
      "qr" 'restart-emacs))
#+END_SRC

[[https://github.com/justbur/emacs-which-key][~which-key~]] displays all of the available keybindings following a incompletely entered command. For
example, pressing ~C-x~ and waiting a moment will cause ~which-key~ to populate the minibuffer with all
the available next keys along with their corresponding commands. This makes discovery of new
commands very easy.

The only slight issue with this is that the size of the minibuffer expands a lot which can cause the
view of the current buffer to change depending on where the point is. ~which-key-posframe~ provides an
improvement on this by popping up in a floating window. I'll try it for a while and see.

#+BEGIN_SRC emacs-lisp
  (use-package which-key
    :custom
    (which-key-idle-delay 0)
    :config
    (which-key-mode +1)
    ;(which-key-setup-minibuffer)
    (which-key-setup-side-window-bottom))

  (use-package which-key-posframe
    :config
    (which-key-posframe-mode)
    (setq which-key-posframe-poshandler 'posframe-poshandler-point-bottom-left-corner))
#+END_SRC

[[https://github.com/abo-abo/hydra][~hydra~]] allows us to specify related keybindings together in a
neat way. Note that ~:wk~ allows us to specify the text that is displayed by ~which-key~ for this hydra.
#+BEGIN_SRC emacs-lisp
  (use-package hydra
    :defer t)

  ;; This allows us to use :hydra within use-package
  (use-package use-package-hydra
    :ensure t)
#+END_SRC

This is a simple hydra to scale the font of the current buffer.

TODO: In future it would be good to improve this to apply the changes to the current frame so that
the changes took affect in all buffers in that frame. There seem to be a few existing options to do
this according to this [[https://stackoverflow.com/questions/24705984/increase-decrease-font-size-in-an-emacs-frame-not-just-buffer][stackoverflow question]].
#+BEGIN_SRC emacs-lisp
  ;; Add an easy zoom function
  (my-leader-def "z" '(hydra-zoom/body :wk "zoom"))
  (defhydra hydra-zoom (:column 2)
      ("n" text-scale-increase "Zoom in")
      ("t" text-scale-decrease "Zoom out")
      ("r" (text-scale-set 0) "Reset zoom")
      ("0" (text-scale-set 0) :bind nil :exit t))
#+END_SRC

This is a basic movement hydra.
#+BEGIN_SRC emacs-lisp
  (general-define-key "C-n" 'hydra-move/body)
  (defhydra hydra-move
    (:body-pre (next-line))
    "navigation"
    ("n" next-line)
    ("p" previous-line)
    ("f" forward-char)
    ("b" backward-char)
    ("a" beginning-of-line)
    ("e" move-end-of-line)
    ("v" scroll-up-command)
    ;; Converting M-v to V here by analogy.
    ("V" scroll-down-command)
    ("l" recenter-top-bottom)
    ("<" beginning-of-buffer)
    (">" end-of-buffer))
#+END_SRC

This is a hydra for working with the ~rectangle~ commands.

TODO: I should understand how this works better.

#+BEGIN_SRC emacs-lisp
  (my-leader-def "R" '(hydra-rectangle/body :wk "rectangle"))
  (defhydra hydra-rectangle (:body-pre (rectangle-mark-mode 1)
                                       :color pink
                                       :hint nil
                                       :post (deactivate-mark))
         "
      ^_i_^       _w_ copy      _O_pen       _N_umber-lines
    _n_   _o_     _y_ank        _t_ype       _E_xchange-point
      ^_e_^       _d_ kill      _c_lear      _r_eset-region-mark
    ^^^^          _u_ndo        _g_ quit     ^ ^
    "
         ("i" rectangle-previous-line)
         ("e" rectangle-next-line)
         ("n" rectangle-backward-char)
         ("o" rectangle-forward-char)
         ("d" kill-rectangle)                    ;; C-x r k
         ("y" yank-rectangle)                    ;; C-x r y
         ("w" copy-rectangle-as-kill)            ;; C-x r M-w
         ("O" open-rectangle)                    ;; C-x r o
         ("t" string-rectangle)                  ;; C-x r t
         ("c" clear-rectangle)                   ;; C-x r c
         ("E" rectangle-exchange-point-and-mark) ;; C-x C-x
         ("N" rectangle-number-lines)            ;; C-x r N
         ("r" (if (region-active-p)
                  (deactivate-mark)
                (rectangle-mark-mode 1)))
         ("u" undo nil)
         ("g" nil))
#+END_SRC

This hydra provides easy access to various package management commands.
#+BEGIN_SRC emacs-lisp
  (my-leader-def "s" '(hydra-straight-helper/body :wk "pkgs"))
  (defhydra hydra-straight-helper (:hint nil :color green)
         "
        _c_heck all       |_f_etch all     |_m_erge all      |_n_ormalize all   |p_u_sh all
        _C_heck package   |_F_etch package |_M_erge package  |_N_ormlize package|p_U_sh package
        ----------------^^+--------------^^+---------------^^+----------------^^+------------||_q_uit||
        _r_ebuild all     |_p_ull all      |_v_ersions freeze|_w_atcher start   |_g_et recipe
        _R_ebuild package |_P_ull package  |_V_ersions thaw  |_W_atcher quit    |prun_e_ build"
         ("c" straight-check-all)
         ("C" straight-check-package)
         ("r" straight-rebuild-all)
         ("R" straight-rebuild-package)
         ("f" straight-fetch-all)
         ("F" straight-fetch-package)
         ("p" straight-pull-all)
         ("P" straight-pull-package)
         ("m" straight-merge-all)
         ("M" straight-merge-package)
         ("n" straight-normalize-all)
         ("N" straight-normalize-package)
         ("u" straight-push-all)
         ("U" straight-push-package)
         ("v" straight-freeze-versions)
         ("V" straight-thaw-versions)
         ("w" straight-watcher-start)
         ("W" straight-watcher-quit)
         ("g" straight-get-recipe)
         ("e" straight-prune-build)
         ("q" nil))
#+END_SRC

This hydra gives easy access to inserting various Unicode characters.
#+BEGIN_SRC emacs-lisp
  (defun my/insert-unicode (unicode-name)
    "Same as C-x 8 enter UNICODE-NAME."
    (insert-char (gethash unicode-name (ucs-names))))

  (my-leader-def "u" '(hydra-unicode/body :wk "unicode"))
  (defhydra hydra-unicode (:hint nil)
    "
          Unicode  _e_ €  _g_ £
                   _f_ ♀  _r_ ♂
                   _o_ °  _m_ µ  _z_ ë  _Z_ Ë
                   _n_ ←  _e_ ↓  _i_ ↑  _o_ →
          "
    ("e" (my/insert-unicode "EURO SIGN"))
    ("g" (my/insert-unicode "POUND SIGN"))

    ("r" (my/insert-unicode "MALE SIGN"))
    ("f" (my/insert-unicode "FEMALE SIGN"))

    ("o" (my/insert-unicode "DEGREE SIGN"))
    ("m" (my/insert-unicode "MICRO SIGN"))

    ("z" (my/insert-unicode "LATIN SMALL LETTER E DIAERESIS"))
    ("Z" (my/insert-unicode "LATIN CAPITAL LETTER E DIAERESIS"))

    ("n" (my/insert-unicode "LEFTWARDS ARROW"))
    ("e" (my/insert-unicode "DOWNWARDS ARROW"))
    ("i" (my/insert-unicode "UPWARDS ARROW"))
    ("o" (my/insert-unicode "RIGHTWARDS ARROW")))
#+END_SRC

This hydra provides easy access to ~register~ functions.
#+BEGIN_SRC emacs-lisp
  (my-leader-def "r" '(hydra-register-helper/body :wk "registers"))
  (defhydra hydra-register-helper (:hint nil :color green)
    "
   Position                   Text
  ----------------------------------------------------
   _p_oint to register        _c_opy to register
   _j_ump to point            _a_ppend to register
                            _P_repend to register
   _l_ist registers           _i_nsert from register"
    ;; Position
    ("p" point-to-register)
    ("j" jump-to-register)
    ("l" helm-register)

    ;; Text
    ("c" copy-to-register)
    ("a" append-to-register)
    ("P" prepend-to-register)
    ("i" insert-register)

    ("q" nil))
#+END_SRC

[[https://github.com/dacap/keyfreq][~keyfreq~]] tracks how many times you use various Emacs commands. This can be helpful to identify
commands that you're using a lot which could benefit from a better keybinding. This is really a
manual way to emulate something like the great Key Promoter X plugin for IntelliJ which tells you
when there's a keyboard shortcut to do something that you've just used the mouse for.
#+BEGIN_SRC emacs-lisp
  (use-package keyfreq
    :init (keyfreq-mode 1)
    :config (keyfreq-autosave-mode 1))
#+END_SRC

** Helm
[[https://github.com/emacs-helm/helm][~helm~]] is a framework for incremental completions and
narrowing selections. It makes it easy to find what you want by filtering as you type.
#+BEGIN_SRC emacs-lisp
  (use-package helm
    :diminish
    :init
    (helm-mode t)
    :config
    (setq helm-buffer-max-length 40
          ;; this stops helm trying to ping websites when it interprets text as a url
          ffap-machine-p-known 'reject
          helm-mini-default-sources '(helm-source-buffers-list
                                  helm-source-recentf
                                  helm-source-bookmarks
                                  helm-source-buffer-not-found
                                  helm-source-bookmark-set))
    ;; TODO why not use general here?
    :bind (("M-x"     . helm-M-x)
           ("C-x C-f" . helm-find-files)
           ("C-x b"   . helm-mini)     ;; See buffers & recent files; more useful.
           ("C-x r b" . helm-filtered-bookmarks)
           ("C-x C-r" . helm-recentf)  ;; Search for recently edited files
           ("C-c i"   . helm-imenu)
           ("C-h a"   . helm-apropos)
           ;; Look at what was cut recently & paste it in.
           ("M-y" . helm-show-kill-ring)

           :map helm-map
           ;; We can list ‘actions’ on the currently selected item by C-z.
           ("C-z" . helm-select-action)
           ;; Let's keep tab-completetion anyhow.
           ("TAB"   . helm-execute-persistent-action)
           ("<tab>" . helm-execute-persistent-action)))
#+END_SRC

[[https://github.com/emacs-helm/helm-descbinds][~helm-descbinds~]] makes it easy to search the current active keybindings using ~helm~.
#+BEGIN_SRC emacs-lisp
  (use-package helm-descbinds
    :config (helm-descbinds-mode))

#+END_SRC

[[https://github.com/emacsorphanage/helm-swoop][~helm-swoop~]] is a useful way to search a buffer using ~helm~.

TODO: there's probably more useful options here I could explore
#+BEGIN_SRC emacs-lisp
  (use-package helm-swoop
    :config
    (setq
     ;; show syntax highlighting in swoop minibuffer
     helm-swoop-speed-or-color t
     ;; don't pre-populate the swoop minibuffer with the symbol at the point
     ;;helm-swoop-pre-input-function (lambda () "")
     helm-swoop-use-fuzzy-matching t)
    :general
    ("C-s"   'helm-swoop)
    ("C-M-s" 'helm-multi-swoop-all)
    ("C-S-s" 'helm-swoop-back-to-last-point)
    ;; keep C-w mapped to backward-kill-word even when swooping
    (helm-swoop-map "C-w" 'backward-kill-word)
    :custom
    (helm-swoop-split-with-multiple-windows t "Do not split window inside the current window."))
#+END_SRC

** Editing

[[https://github.com/bbatsov/crux][~crux~]] has a bunch of handy editing features that originated in Prelude Emacs.
#+BEGIN_SRC emacs-lisp
  (use-package crux
    :general
    ;; First kill to end of line, then kill the whole then.
    ("C-k" 'crux-smart-kill-line))
#+END_SRC

This snippet provides smarter moving to the beginning of the line.
Copied from [[https://emacsredux.com/blog/2013/05/22/smarter-navigation-to-the-beginning-of-a-line/]].
#+BEGIN_SRC emacs-lisp
  (defun smarter-move-beginning-of-line (arg)
    "Move point back to indentation of beginning of line.

    Move point to the first non-whitespace character on this line.
    If point is already there, move to the beginning of the line.
    Effectively toggle between the first non-whitespace character and
    the beginning of the line.

    If ARG is not nil or 1, move forward ARG - 1 lines first.  If
    point reaches the beginning or end of the buffer, stop there."
    (interactive "^p")
    (setq arg (or arg 1))

    ;; Move lines first
    (when (/= arg 1)
      (let ((line-move-visual nil))
        (forward-line (1- arg))))

    (let ((orig-point (point)))
      (back-to-indentation)
      (when (= orig-point (point))
        (move-beginning-of-line 1))))

  ;; remap C-a to `smarter-move-beginning-of-line'
  (general-define-key "C-a" 'smarter-move-beginning-of-line)
#+END_SRC

[[https://elpa.gnu.org/packages/undo-tree.html][~undo-tree~]] gives a nice undo visualisation.

TODO this is a nice way to incorporate Hydras directly into the use-package setup.

TODO this doesn't seem to be enabled by default, at least in org, or Go. Maybe add hooks

TODO try vundo instead https://github.com/casouri/vundo
#+BEGIN_SRC emacs-lisp
  (use-package undo-tree
    :ensure t
    :diminish
    :after hydra
    :general ("C-x /" 'hydra-undo-tree/body)
    :config
      (global-undo-tree-mode 1)
      (setq undo-tree-visualizer-timestamps t
            undo-tree-visualizer-diff t
            undo-tree-show-minibuffer-help t
            undo-tree-minibuffer-help-dynamic t
            undo-tree-show-help-in-visualize-buffer t)
    :hydra (hydra-undo-tree (:hint nil)
  "
  _p_: undo  _n_: redo _s_: save _l_: load   "
      ("p"   undo-tree-undo)
      ("n"   undo-tree-redo)
      ("s"   undo-tree-save-history)
      ("l"   undo-tree-load-history)
      ("u"   undo-tree-visualize "visualize" :color blue)
      ("q"   nil "quit" :color blue)))
  ; This helps undo-tree keep loading: https://github.com/syl20bnr/spacemacs/issues/14064
  (with-eval-after-load 'undo-tree (defun undo-tree-overridden-undo-bindings-p () nil))
#+END_SRC

[[https://github.com/waymondo/popup-kill-ring][~popup-kill-ring~]] displays the kill-ring in a popup at the point.
#+begin_src emacs-lisp
(use-package popup-kill-ring
  :bind ("M-y" . popup-kill-ring))
#+end_src

[[https://github.com/victorhge/iedit][~iedit~]] allows you edit multiple occurrences of the same symbol at the same time. It's less useful
now that ~lsp-mode~ can do the same thing across a project, but it is still useful for non-lsp enabled
content.
#+BEGIN_SRC emacs-lisp
  (use-package iedit)
#+END_SRC

[[https://github.com/emacs-dashboard/emacs-dashboard][~dashboard~]] is a nice little splash screen that shows some recent items on starting Emacs.
#+BEGIN_SRC emacs-lisp
  (use-package dashboard
    :config
    (dashboard-setup-startup-hook)
    (setq initial-buffer-choice (lambda () (get-buffer "*dashboard*")))
    (setq dashboard-items '((recents  . 5)
                            (bookmarks . 5)
                            (projects . 5)
                            (registers . 5)))
    (setq dashboard-set-heading-icons t)
    (setq dashboard-set-file-icons t)
    (setq dashboard-init-info (concat "Welcome "     user-full-name
                                      "! Emacs "      emacs-version
                                      "; System "     (system-name)
                                      "; Time "       (emacs-init-time))))
#+END_SRC


~dired~ is basically a file explorer.
#+BEGIN_SRC emacs-lisp
  (use-package dired
    :straight nil
    :defer t
    :hook (dired-mode . dired-hide-details-mode)
    :general
    (my-leader-def
      "d" 'dired)
    (dired-mode-map "." 'hydra-dired/body)
    :hydra
    ;; TODO map 'c' to copy, r to rename
    (hydra-dired (:hint nil :color pink)
    "
  _+_ mkdir          _v_iew           _m_ark             _(_ details        _i_nsert-subdir    wdired
  _C_opy             _O_ view other   _U_nmark all       _)_ omit-mode      _$_ hide-subdir    C-x C-q : edit
  _D_elete           _o_pen other     _u_nmark           _l_ redisplay      _w_ kill-subdir    C-c C-c : commit
  _R_ename           _M_ chmod        _t_oggle           _g_ revert buf     _e_ ediff          C-c ESC : abort
  _Y_ rel symlink    _G_ chgrp        _E_xtension mark   _s_ort             _=_ pdiff
  _S_ymlink          ^ ^              _F_ind marked      _._ toggle hydra   \\ flyspell
  _r_sync            ^ ^              ^ ^                ^ ^                _?_ summary
  _z_ compress-file  _A_ find regexp
  _Z_ compress       _Q_ repl regexp

  T - tag prefix
  "
      ("\\" dired-do-ispell)
      ("(" dired-hide-details-mode)
      (")" dired-omit-mode)
      ("+" dired-create-directory)
      ("=" diredp-ediff)         ;; smart diff
      ("?" dired-summary)
      ("$" diredp-hide-subdir-nomove)
      ("A" dired-do-find-regexp)
      ("C" dired-do-copy)        ;; Copy all marked files
      ("D" dired-do-delete)
      ("E" dired-mark-extension)
      ("e" dired-ediff-files)
      ("F" dired-do-find-marked-files)
      ("G" dired-do-chgrp)
      ("g" revert-buffer)        ;; read all directories again (refresh)
      ("i" dired-maybe-insert-subdir)
      ("l" dired-do-redisplay)   ;; relist the marked or singel directory
      ("M" dired-do-chmod)
      ("m" dired-mark)
      ("O" dired-display-file)
      ("o" dired-find-file-other-window)
      ("Q" dired-do-find-regexp-and-replace)
      ("R" dired-do-rename)
      ("r" dired-do-rsynch)
      ("S" dired-do-symlink)
      ("s" dired-sort-toggle-or-edit)
      ("t" dired-toggle-marks)
      ("U" dired-unmark-all-marks)
      ("u" dired-unmark)
      ("v" dired-view-file)      ;; q to exit, s to search, = gets line #
      ("w" dired-kill-subdir)
      ("Y" dired-do-relsymlink)
      ("z" diredp-compress-this-file)
      ("Z" dired-do-compress)
      ("q" nil)
      ("." nil :color blue)))

  ;; Colourful columns.
  (use-package diredfl
    :after dired
    :config
    (diredfl-global-mode +1))

  (use-package dired-git-info
      :general ('dired-mode-map
                "C-(" 'dired-git-info-mode))
#+END_SRC

** Projectile
[[https://projectile.mx/][~projectile~]] is a project interaction package that provides lots of handy commands for operating at
a project level.

TODO: I should probably trim down this hydra since I don't use some of it.
#+BEGIN_SRC emacs-lisp
  (use-package projectile
    :general
    (my-leader-def
      "h" '(hydra-projectile/body :wk "projectile-mode")) ;;oryx
    (projectile-mode-map "C-c h" 'projectile-command-map)
    :config
    (projectile-mode +1)
    :hydra
    (hydra-projectile (:color teal
                              :hint nil)
    "
       PROJECTILE: %(projectile-project-root)

       Find File            Search/Tags          Buffers                Cache
  ------------------------------------------------------------------------------------------
  _s-f_: file            _a_: ag                _i_: Ibuffer           _c_: cache clear
   _ff_: file dwim       _g_: update gtags      _b_: switch to buffer  _x_: remove known project
   _fd_: file curr dir   _o_: multi-occur     _s-k_: Kill all buffers  _X_: cleanup non-existing
    _r_: recent file                                               ^^^^_z_: cache current
    _d_: dir

  "
      ("a"   helm-rg)
      ("b"   projectile-switch-to-buffer)
      ("c"   projectile-invalidate-cache)
      ("d"   projectile-find-dir)
      ("s-f" projectile-find-file)
      ("ff"  projectile-find-file-dwim)
      ("fd"  projectile-find-file-in-directory)
      ("g"   ggtags-update-tags)
      ("s-g" ggtags-update-tags)
      ("i"   projectile-ibuffer)
      ("K"   projectile-kill-buffers)
      ("s-k" projectile-kill-buffers)
      ("m"   projectile-multi-occur)
      ("o"   projectile-multi-occur)
      ("s-p" projectile-switch-project "switch project")
      ("p"   projectile-switch-project)
      ("s"   projectile-switch-project)
      ("r"   projectile-recentf)
      ("x"   projectile-remove-known-project)
      ("X"   projectile-cleanup-known-projects)
      ("z"   projectile-cache-current-file)
      ("`"   hydra-projectile-other-window/body "other window")
      ("q"   nil "cancel" :color blue)))
#+END_SRC

TODO: commentary
#+BEGIN_SRC emacs-lisp
  (use-package ibuffer-vc
    :config
    (add-hook 'ibuffer-hook #'ibuffer-vc-set-filter-groups-by-vc-root))

  (use-package ibuffer-projectile)
#+END_SRC

TODO: commentary
#+BEGIN_SRC emacs-lisp
  (use-package helm-projectile
    :after projectile
    :config
    (helm-projectile-on))

  (use-package helm-rg
    :ensure t
    :config
    (setq helm-rg-default-directory 'git-root))

  (use-package helm-ag
    :ensure t
    :config
    (setq ag-arguments (list "--smart-case" "--column")))
#+END_SRC

** Org
TODO: commentary
#+BEGIN_SRC emacs-lisp
  (defun my-org-prettify-hook ()
    (turn-on-visual-line-mode))

  (defun my-org-prettify-settings ()
    (setq org-startup-indented nil
          org-src-fontify-natively t
          org-hide-emphasis-markers t
          org-fontify-whole-heading-line t
          org-fontify-done-headline t
          org-fontify-quote-and-verse-blocks t
          line-spacing 0.2))
#+END_SRC

[[https://github.com/hniksic/emacs-htmlize][~htmlize~]] converts a buffer to HTML.
#+BEGIN_SRC emacs-lisp
  (use-package htmlize
    :defer t)
#+END_SRC

TODO: commentary
#+BEGIN_SRC emacs-lisp
  (defun my-org-todo-setup ()
    (setq org-use-fast-todo-selection t)
    (setq org-todo-keywords
          '((sequence "TODO(t)" "NEXT(n)" "CURRENT(c)" "|" "DONE(d)")
            (sequence "WAITING(w@/!)" "HOLD(h@/!)" "|" "CANCELLED(a@/!)")
            (type "MEETING")))
    (setq org-log-done 'time)
    (setq org-todo-keyword-faces
          (quote (("TODO" :foreground "red" :weight bold)
                  ("NEXT" :foreground "blue" :weight bold)
                  ("DONE" :foreground "forest green" :weight bold)
                  ("WAITING" :foreground "orange" :weight bold)
                  ("HOLD" :foreground "magenta" :weight bold)
                  ("CANCELLED" :foreground "forest green" :weight bold)
                  ("MEETING" :foreground "forest green" :weight bold)
                  ("PHONE" :foreground "forest green" :weight bold)))))
#+END_SRC

TODO: commentary
#+BEGIN_SRC emacs-lisp
  (defun my-org-structure-templates ()
    (require 'org-tempo)
    (add-to-list 'org-structure-template-alist '("el" . "src emacs-lisp"))
    (add-to-list 'org-structure-template-alist '("sh" . "src sh")))

  ;; todo this shuold be part of the org setup
  (defhydra hydra-org-template (:color blue :hint nil)
    "
   _c_enter  _q_uote     _e_macs-lisp    _L_aTeX:
   _l_ink    _E_xample   _p_erl          _i_ndex:
   _a_scii   _v_erse     _P_erl tangled  _I_NCLUDE:
   _s_rc     _n_ote      plant_u_ml      _H_TML:
   _h_tml    ^ ^         ^ ^             _A_SCII:
  "
    ("s" (hot-expand "<s"))
    ("E" (hot-expand "<e"))
    ("q" (hot-expand "<q"))
    ("v" (hot-expand "<v"))
    ("n" (hot-expand "<not"))
    ("c" (hot-expand "<c"))
    ("l" (hot-expand "<li"))
    ("h" (hot-expand "<h"))
    ("a" (hot-expand "<a"))
    ("L" (hot-expand "<L"))
    ("i" (hot-expand "<i"))
    ("e" (hot-expand "<s" "emacs-lisp"))
    ("p" (hot-expand "<s" "perl"))
    ("u" (hot-expand "<s" "plantuml :file CHANGE.png"))
    ("P" (hot-expand "<s" "perl" ":results output :exports both :shebang \"#!/usr/bin/env perl\"\n"))
    ("I" (hot-expand "<I"))
    ("H" (hot-expand "<H"))
    ("A" (hot-expand "<A"))
    ("<" self-insert-command "ins")
    ("o" nil "quit"))

  (require 'org-tempo) ; Required from org 9 onwards for old template expansion
  ;; Reset the org-template expnsion system, this is need after upgrading to org 9 for some reason
  (setq org-structure-template-alist (eval (car (get 'org-structure-template-alist 'standard-value))))
  (defun hot-expand (str &optional mod header)
    "Expand org template.

  STR is a structure template string recognised by org like <s. MOD is a
  string with additional parameters to add the begin line of the
  structure element. HEADER string includes more parameters that are
  prepended to the element after the #+HEADER: tag."
    (let (text)
      (when (region-active-p)
        (setq text (buffer-substring (region-beginning) (region-end)))
        (delete-region (region-beginning) (region-end))
        (deactivate-mark))
      (when header (insert "#+HEADER: " header) (forward-line))
      (insert str)
      (org-tempo-complete-tag)
      (when mod (insert mod) (forward-line))
      (when text (insert text))))

  (general-define-key
   :keymaps 'org-mode-map
   ;; disable this agenda key since I use it for avy
   "C-'" nil
   "<" '(lambda () (interactive)
          (if (or (region-active-p) (looking-back "^"))
              (hydra-org-template/body)
            (self-insert-command 1))))

  (eval-after-load "org"
    '(cl-pushnew
      '("not" . "note")
      org-structure-template-alist))
#+END_SRC

TODO: commentary
#+BEGIN_SRC emacs-lisp
  (use-package org-capture
    :straight nil
    :general
    (my-leader-def
      "C" 'org-capture)
    :config
    (setq org-capture-templates
          '(
            ("c" "Note on current task" plain (clock) "\n\n%T from: %a\n%i\n%?")
            ("s" "Standup" entry (file+olp+datetree (concat my/org-dir "todo.org") "Standup") "* Planned\n- %?\n %i\n %a")
            ("r" "To-Read" item (file+headline (lamdba () (concat my/org-dir "personal.org")) "To Read") "")
            ("t" "Tasks")
            ("tw" "Work Task" entry (file+headline (lambda () (concat my/org-dir "work/swrx.org")) "Tasks") "** TODO %?\n %i")
            ("tp" "Pesonal Task" entry (file+headline (lambda () (concat my/org-dir "personal.org")) "Tasks") "* TODO %?\n %i\n %a")
            ("th" "Household Task" entry (file+headline (lambda () (concat my/org-dir "household.org")) "Tasks") "* TODO %?\n %i\n %a")
            ("i" "Interruption")
            ("ii" "interruption" entry (file+olp+datetree (lambda () (concat my/org-dir "tracker.org"))) "* IN-PROGRESS %?  :interruption:work:\n%U\n- ref :: %a\n"
             :prepend t :tree-type week :clock-in t :clock-keep t)
            ("ic" "chat"         entry (file+olp+datetree (lambda () (concat my/org-dir "tracker.org"))) "* CHAT %?         :work:chat:\n%U\n- ref :: %a\n"
             :prepend t :tree-type week :clock-in t :clock-keep t)
            ("ie" "email"        entry (file+olp+datetree (lambda () (concat my/org-dir "tracker.org"))) "* EMAIL %?        :work:email:\n%U\n- ref :: %a\n"
             :prepend t :tree-type week :clock-in t :clock-keep t)
            ("im" "meeting"      entry (file+olp+datetree (lambda () (concat my/org-dir "tracker.org")))  "* MEETING %?      :work:meeting:\n%U\n- ref :: %a\n"
             :prepend t :tree-type week :clock-in t :clock-keep t)
            ("ir" "review"       entry (file+olp+datetree (lambda () (concat my/org-dir "tracker.org")))  "* REVIEW %?       :work:review:\n%U\n- ref :: %a\n"
             :prepend t :tree-type week :clock-in t :clock-keep t)
            ))

    (defun org-hugo-new-subtree-post-capture-template ()
      "Returns `org-capture' template string for new Hugo post.
  See `org-capture-templates' for more information."
      (let* ((title (read-from-minibuffer "Post Title: ")) ;Prompt to enter the post title
             (fname (org-hugo-slug title)))
        (mapconcat #'identity
                   `(
                     ,(concat "* TODO " title)
                     ":PROPERTIES:"
                     ,(concat ":EXPORT_FILE_NAME: " fname)
                     ":END:"
                     "%?\n")          ;Place the cursor here finally
                   "\n")))

    (add-to-list 'org-capture-templates
                 '("b"
                   "Blog Post"
                   entry
                   ;; It is assumed that below file is present in `org-directory'
                   ;; and that it has a "Blog Ideas" heading. It can even be a
                   ;; symlink pointing to the actual location of all-posts.org!
                   (file+olp "blog-posts.org" "Ideas")
                   (function org-hugo-new-subtree-post-capture-template))))
  (add-hook 'org-mode-hook (lambda ()
     "Beautify Org Checkbox Symbol"
     (push '("[ ]" . "☐") prettify-symbols-alist)
     (push '("[X]" . "☑" ) prettify-symbols-alist)
     (push '("[-]" . "❍" ) prettify-symbols-alist)
     (prettify-symbols-mode)))

  (add-hook 'org-mode-hook 'turn-on-auto-fill)
#+END_SRC

TODO: straight should be t here
#+BEGIN_SRC emacs-lisp
  (use-package org
    :straight nil
    :gfhook
    #'my-org-prettify-hook
    ('org-src-mode-hook #'my-disable-flycheck-for-elisp)
    :preface
    (defun my-disable-flycheck-for-elisp ()
      (setq flycheck-disabled-checkers '(emacs-lisp-checkdoc)))
    :general
    ("C-c l" 'org-store-link)
    (org-mode-map "C-'" nil)

    :config
    (setq org-agenda-files my/org-agenda-files
          org-directory my/org-dir
          org-tags-column 75
          org-log-into-drawer t ;; hide the log state change history a bit better
          org-deadline-warning-days 7
          org-agenda-skip-scheduled-if-deadline-is-shown t
          org-habit-show-habits-only-for-today nil
          org-habit-graph-column 65
          org-duration-format 'h:mm ;; show hours at max, not days
          org-agenda-compact-blocks t
          org-cycle-separator-lines 0
          ;; hide empty agenda sections
          org-agenda-clockreport-parameter-plist '(:stepskip0 t :link t :maxlevel 2 :fileskip0 t)
          ;; default show today
          org-agenda-span 'day
          org-agenda-start-day "-0d"
          org-agenda-start-on-weekday 1
          org-agenda-custom-commands
          '(("d" "Done tasks" tags "/DONE|CANCELED")
            ("g" "Plan Today"
             ((agenda "" ((org-agenda-span 'day)))
              (org-agenda-skip-function '(org-agenda-skip-deadline-if-not-today))
              (org-agenda-entry-types '(:deadline))
              (org-agenda-overriding-header "Today's Deadlines "))))
          )
    (my-org-prettify-settings)
    (my-org-todo-setup)
    (my-org-structure-templates))
#+END_SRC

TODO: commentary
#+BEGIN_SRC emacs-lisp
  (use-package org-super-agenda
    :after org-agenda
    :custom (org-super-agenda-groups
             '( ;; Each group has an implicit boolean OR operator between its selectors.
               (:name "Overdue" :deadline past :order 0)
               (:name "Evening Habits" :and (:habit t :tag "evening") :order 8)
               (:name "Habits" :habit t :order 6)
               (:name "Today" ;; Optionally specify section name
                      :time-grid t  ;; Items that appear on the time grid (scheduled/deadline with time)
                      :order 3)     ;; capture the today first but show it in order 3
               (:name "Low Priority" :priority "C" :tag "maybe" :order 7)
               (:name "Due Today" :deadline today :order 1)
               (:name "Important"
                      :and (:priority "A" :not (:todo ("DONE" "CANCELED")))
                      :order 2)
               (:name "Due Soon" :deadline future :order 4)
               (:name "Todo" :not (:habit t) :order 5)
               (:name "Waiting" :todo ("WAITING" "HOLD") :order 9)))
    :config
    (setq org-super-agenda-header-map nil
          org-super-agenda-mode t))


  (defhydra hydra-org-agenda (:pre (setq which-key-inhibit t)
                                   :post (setq which-key-inhibit nil)
                                   :hint nil)
    "
  Org agenda (_q_uit)

  ^Clock^      ^Visit entry^              ^Date^             ^Other^
  ^-----^----  ^-----------^------------  ^----^-----------  ^-----^---------
  _ci_ in      _SPC_ in other window      _ds_ schedule      _gr_ reload
  _co_ out     _TAB_ & go to location     _dd_ set deadline  _._  go to today
  _cq_ cancel  _RET_ & del other windows  _dt_ timestamp     _gd_ go to date
  _cj_ jump    _o_   link                 _+_  do later      ^^
  ^^           ^^                         _-_  do earlier    ^^
  ^^           ^^                         ^^                 ^^
  ^View^          ^Filter^                 ^Headline^         ^Toggle mode^
  ^----^--------  ^------^---------------  ^--------^-------  ^-----------^----
  _vd_ day        _ft_ by tag              _ht_ set status    _tf_ follow
  _vw_ week       _fr_ refine by tag       _hk_ kill          _tl_ log
  _vt_ fortnight  _fc_ by category         _hr_ refile        _ta_ archive trees
  _vm_ month      _fh_ by top headline     _hA_ archive       _tA_ archive files
  _vy_ year       _fx_ by regexp           _h:_ set tags      _tr_ clock report
  _vn_ next span  _fd_ delete all filters  _hp_ set priority  _td_ diaries
  _vp_ prev span  ^^                       ^^                 ^^
  _vr_ reset      ^^                       ^^                 ^^
  ^^              ^^                       ^^                 ^^
  "
    ;; Entry
    ("hA" org-agenda-archive-default)
    ("hk" org-agenda-kill)
    ("hp" org-agenda-priority)
    ("hr" org-agenda-refile)
    ("h:" org-agenda-set-tags)
    ("ht" org-agenda-todo)
    ;; Visit entry
    ("o"   link-hint-open-link :exit t)
    ("<tab>" org-agenda-goto :exit t)
    ("TAB" org-agenda-goto :exit t)
    ("SPC" org-agenda-show-and-scroll-up)
    ("RET" org-agenda-switch-to :exit t)
    ;; Date
    ("dt" org-agenda-date-prompt)
    ("dd" org-agenda-deadline)
    ("+" org-agenda-do-date-later)
    ("-" org-agenda-do-date-earlier)
    ("ds" org-agenda-schedule)
    ;; View
    ("vd" org-agenda-day-view)
    ("vw" org-agenda-week-view)
    ("vt" org-agenda-fortnight-view)
    ("vm" org-agenda-month-view)
    ("vy" org-agenda-year-view)
    ("vn" org-agenda-later)
    ("vp" org-agenda-earlier)
    ("vr" org-agenda-reset-view)
    ;; Toggle mode
    ("ta" org-agenda-archives-mode)
    ("tA" (org-agenda-archives-mode 'files))
    ("tr" org-agenda-clockreport-mode)
    ("tf" org-agenda-follow-mode)
    ("tl" org-agenda-log-mode)
    ("td" org-agenda-toggle-diary)
    ;; Filter
    ("fc" org-agenda-filter-by-category)
    ("fx" org-agenda-filter-by-regexp)
    ("ft" org-agenda-filter-by-tag)
    ("fr" org-agenda-filter-by-tag-refine)
    ("fh" org-agenda-filter-by-top-headline)
    ("fd" org-agenda-filter-remove-all)
    ;; Clock
    ("cq" org-agenda-clock-cancel)
    ("cj" org-agenda-clock-goto :exit t)
    ("ci" org-agenda-clock-in :exit t)
    ("co" org-agenda-clock-out)
    ;; Other
    ("q" nil :exit t)
    ("gd" org-agenda-goto-date)
    ("." org-agenda-goto-today)
    ("gr" org-agenda-redo))
  ;; TODO: This doesn't seem to load automatically
  (general-define-key
    :keymaps 'org-agenda-mode-map
    "." 'hydra-org-agenda/body)

  (use-package org-journal
    :defer t
    :config
    (setq org-journal-dir (concat my/org-dir "journal"))
    (setq org-journal-date-format "%A %d %B %Y")
    (setq org-journal-time-format "%H:%M")
    (setq org-journal-enable-agenda-integration t)
    (setq org-journal-file-format "%Y%m%d.org")
    :general ("C-x C-j" 'org-journal-new-entry))

  (use-package org-babel
    :no-require
    :straight nil
    :config
    (org-babel-do-load-languages
     'org-babel-load-languages
     '((python . t)
       (shell . t)
       (plantuml . t))))
#+END_SRC

** Writing Modes

[[https://github.com/rnkn/olivetti][~olivetti~]] formats a buffer for easy prose editing by providing nice margins and a sensibly sized
column of text.
#+BEGIN_SRC emacs-lisp
  (use-package olivetti
    :defer t
    :custom
    (olivetti-body-width 90))
#+END_SRC

[[https://github.com/bnbeckwith/writegood-mode][~writegood-mode~]] provides a bunch of useful functions for better writing, like finding weasel words
and scoring the reading ease of prose.
#+BEGIN_SRC emacs-lisp
(use-package writegood-mode
    :defer t)
#+END_SRC

This is a function to turn on all the various writing modes.
#+BEGIN_SRC emacs-lisp
  (defun my/writing-modes ()
    (interactive)
    (flyspell-mode +1)
    (olivetti-mode +1)
    (writegood-mode +1))
#+END_SRC

*** Spelling
~flyspell~ is Emacs' spelling mode. I've added a decent hydra here for convenience.
#+BEGIN_SRC emacs-lisp
  (setenv "LANG" "en_GB")
  (use-package flyspell
    :diminish
    :general
    (my-leader-def
      "n" 'hydra-spelling/body) ;;oryx: just 'c' would be better here
    :hook ((prog-mode . flyspell-prog-mode)
           ((org-mode text-mode) . flyspell-mode))
    :config
    (setq ispell-dictionary "english"
          ispell-silently-savep t
          ispell-personal-dictionary "~/.emacs.d/.aspell.en.pws")
    :hydra (hydra-spelling (:color blue :hint nil)
      "
  ^
  ^Spelling^          ^Errors^            ^Checker^
  ^────────^──────────^──────^────────────^───────^───────
  _q_ quit            _<_ previous        _c_ correction
  ^^                  _>_ next            _d_ dictionary
  ^^                  _f_ check           _m_ mode
  ^^                  ^^                  ^^
  "
      ("q" nil)
      ("<" flyspell-correct-previous :color pink)
      (">" flyspell-correct-next :color pink)
      ("c" ispell)
      ("d" ispell-change-dictionary)
      ("f" flyspell-buffer)
      ("m" flyspell-mode)))

  (use-package flyspell-correct
    :after flyspell)
  ;;TODO am I using this?
  (use-package flyspell-correct-helm
    :after flyspell)
#+END_SRC

TODO: commentary
#+BEGIN_SRC emacs-lisp
  (use-package expand-region
    :general
    ("C->" 'er/expand-region)
    ("C-<" 'er/contract-region))
#+END_SRC

TODO: commentary
#+BEGIN_SRC emacs-lisp
  (use-package flycheck
    :general
    (my-leader-def
      "f" '(hydra-flycheck-mode/body :wk "flycheck-mode"))
    :config
    (global-flycheck-mode +1)
    (setq-default flycheck-disabled-checkers '(json-python-json))
    :hydra
    (hydra-flycheck-mode
      (:hint nil
       :color green
       :pre (flycheck-list-errors)
       :post (quit-windows-on "*Flycheck errors*"))
      "
  Find Errors        Describe Errors
  -----------------------------------
  _f_irst error      _s_how error
  _n_ext error       _e_xplain error
  _p_rev error       ^ ^
  _l_ist errors      ^ ^
  "
      ("f" flycheck-first-error)
      ("n" flycheck-next-error)
      ("p" flycheck-previous-error)
      ("l" flycheck-list-errors)
      ("s" flycheck-display-error-at-point)
      ("e" flycheck-explain-error-at-point)))
#+END_SRC

TODO: commentary
#+BEGIN_SRC emacs-lisp
  (use-package yasnippet
   :custom
   (yas-snippet-dirs
    '("~/.emacs.d/snippets"))
   :config
   (yas-global-mode +1))

  (use-package yasnippet-snippets
    :after yasnippet)
#+END_SRC

** Completion
TODO: commentary
#+BEGIN_SRC emacs-lisp
  (use-package company
    :diminish
    :ensure t
    :config
    (global-company-mode 1)
    (setq ;; Only 1 letters required for completion to activate.
     company-minimum-prefix-length 1
     ;; Search other buffers for compleition candidates
     company-dabbrev-other-buffers t
     company-dabbrev-code-other-buffers t
     ;; Show candidates according to importance, then case, then in-buffer frequency
     company-transformers ;'(company-sort-by-backend-importance
                          ;  company-sort-prefer-same-case-prefix
                            '(company-sort-by-occurrence)
     ;; Flushright any annotations for a compleition;
     ;; e.g., the description of what a snippet template word expands into.
     company-tooltip-align-annotations t
     ;; Allow (lengthy) numbers to be eligible for completion.
     company-complete-number nil
     ;; M-⟪num⟫ to select an option according to its number.
     company-show-numbers t
     ;; Show 10 items in a tooltip; scrollbar otherwise or C-s ^_^
     company-tooltip-limit 10
     ;; Edge of the completion list cycles around.
     company-selection-wrap-around t
     ;; Do not downcase completions by default.
     company-dabbrev-downcase nil
     ;; Even if I write something with the ‘wrong’ case,
     ;; provide the ‘correct’ casing.
     company-dabbrev-ignore-case nil
     ;; Immediately activate completion.
     company-idle-delay 0
     ;;company-backends (mapcar #'company-mode/backend-with-yas company-backends)
     ;;company-backends '((:separate company-capf company-yasnippet))
     ;; don't try to complete numbers
     company-dabbrev-char-regexp "[A-z:-]"
     )

    ;; Added from https://emacs.stackexchange.com/questions/10431/get-company-to-show-suggestions-for-yasnippet-names
    (defvar company-mode/enable-yas t
      "Enable yasnippet for all backends.")
    (defun company-mode/backend-with-yas (backend)
      (if (or (not company-mode/enable-yas) (and (listp backend) (member 'company-yasnippet backend)))
          backend
        (append (if (consp backend) backend (list backend))
                '(:with company-yasnippet))))
    (setq company-backends (mapcar #'company-mode/backend-with-yas company-backends))

    ;; Bindings when the company list is active.
    :general
    ;; TODO add cancel binding
    (company-active-map
     "C-d" 'company-show-doc-buffer ;; In new temp buffer
     "<tab>" 'company-complete-selection
     ;; Keep this as the global binding
     "C-w" 'backward-kill-word
     ;; Use C-n,p for navigation in addition to M-n,p
     ;;"C-n" '(lambda () (interactive) (company-complete-common-or-cycle 1))
     ;;"C-p" '(lambda () (interactive) (company-complete-common-or-cycle -1))
     ))
#+END_SRC

Nice icons for company-mode. These are the Doom Emacs defaults, taken from:
https://github.com/TheBB/dotemacs/blob/master/init.el#L527-L570
#+BEGIN_SRC emacs-lisp
  (use-package company-box
    :diminish company-box-mode
    :hook (company-mode . company-box-mode)
    :init
    (setq company-box-icons-alist 'company-box-icons-all-the-icons)
    :config
    (setq company-box-icons-alist 'company-box-icons-all-the-icons
          company-box-backends-colors nil
          company-box-icons-all-the-icons
          `((Unknown       . ,(all-the-icons-material "find_in_page"             :face 'all-the-icons-purple))
            (Text          . ,(all-the-icons-material "text_fields"              :face 'all-the-icons-green))
            (Method        . ,(all-the-icons-material "functions"                :face 'all-the-icons-red))
            (Function      . ,(all-the-icons-material "functions"                :face 'all-the-icons-red))
            (Constructor   . ,(all-the-icons-material "functions"                :face 'all-the-icons-red))
            (Field         . ,(all-the-icons-material "functions"                :face 'all-the-icons-red))
            (Variable      . ,(all-the-icons-material "adjust"                   :face 'all-the-icons-blue))
            (Class         . ,(all-the-icons-material "class"                    :face 'all-the-icons-red))
            (Interface     . ,(all-the-icons-material "settings_input_component" :face 'all-the-icons-red))
            (Module        . ,(all-the-icons-material "view_module"              :face 'all-the-icons-red))
            (Property      . ,(all-the-icons-material "settings"                 :face 'all-the-icons-red))
            (Unit          . ,(all-the-icons-material "straighten"               :face 'all-the-icons-red))
            (Value         . ,(all-the-icons-material "filter_1"                 :face 'all-the-icons-red))
            (Enum          . ,(all-the-icons-material "plus_one"                 :face 'all-the-icons-red))
            (Keyword       . ,(all-the-icons-material "filter_center_focus"      :face 'all-the-icons-red))
            (Snippet       . ,(all-the-icons-material "short_text"               :face 'all-the-icons-red))
            (Color         . ,(all-the-icons-material "color_lens"               :face 'all-the-icons-red))
            (File          . ,(all-the-icons-material "insert_drive_file"        :face 'all-the-icons-red))
            (Reference     . ,(all-the-icons-material "collections_bookmark"     :face 'all-the-icons-red))
            (Folder        . ,(all-the-icons-material "folder"                   :face 'all-the-icons-red))
            (EnumMember    . ,(all-the-icons-material "people"                   :face 'all-the-icons-red))
            (Constant      . ,(all-the-icons-material "pause_circle_filled"      :face 'all-the-icons-red))
            (Struct        . ,(all-the-icons-material "streetview"               :face 'all-the-icons-red))
            (Event         . ,(all-the-icons-material "event"                    :face 'all-the-icons-red))
            (Operator      . ,(all-the-icons-material "control_point"            :face 'all-the-icons-red))
            (TypeParameter . ,(all-the-icons-material "class"                    :face 'all-the-icons-red))
            (Template      . ,(all-the-icons-material "short_text"               :face 'all-the-icons-green))))
    )
#+END_SRC

TODO: commentary
#+BEGIN_SRC emacs-lisp
  (use-package smartscan
    :hook ((prog-mode . smartscan-mode))
    :general
    ("M-n" 'smartscan-symbol-go-forward)
    ("M-p" 'smartscan-symbol-go-backward)
    ("M-'" 'my/symbol-replace))

  (defun my/symbol-replace (replacement)
    "Replace all standalone symbols in the buffer matching the one at point."
    (interactive  (list (read-from-minibuffer "Replacement for thing at point: " nil)))
    (save-excursion
      (let ((symbol (or (thing-at-point 'symbol) (error "No symbol at point!"))))
        (beginning-of-buffer)
        ;; (query-replace-regexp symbol replacement)
        (replace-regexp (format "\\b%s\\b" (regexp-quote symbol)) replacement))))
#+END_SRC

TODO: what is this?
#+BEGIN_SRC emacs-lisp
  (use-package editorconfig
    :delight
    :config
    (editorconfig-mode +1))
#+END_SRC

** Git
TODO: commentary
#+BEGIN_SRC emacs-lisp
  (use-package magit
    :defer t
    :general
    ("C-x g" 'magit-status)
    (my-leader-def
      "g" '(:ignore t :wk "git")
      "gs" 'magit-status
      "gc" 'magit-checkout
      "gC" 'magit-commit
      "gb" 'magit-blame
      "gS" 'magit-stage-file
      "gU" 'magit-unstage-file
      "gg" 'hydra-my-git-menu/body
      "gy" 'my/magit-yank-branch-name)
    :config
    (setq magit-display-buffer-function #'magit-display-buffer-fullframe-status-v1)
    (defun my/magit-yank-branch-name ()
      "Show the current branch in the echo-area and add it to the `kill-ring'."
      (interactive)
      (let ((branch (magit-get-current-branch)))
        (if branch
            (progn (kill-new branch)
                   (message "%s" branch))
          (user-error "There is not current branch")))))
#+END_SRC
TODO: commentary
#+BEGIN_SRC emacs-lisp
  (use-package git-timemachine
    :defer t)
#+END_SRC
TODO: commentary
#+BEGIN_SRC emacs-lisp
  (use-package git-messenger
    :defer t)
#+END_SRC
TODO: commentary
#+BEGIN_SRC emacs-lisp
  (use-package git-gutter-fringe
    :config
    (global-git-gutter-mode +1)
    (setq-default fringes-outside-margins t))
#+END_SRC
TODO: commentary
#+BEGIN_SRC emacs-lisp
  (use-package git-link
    :general
    (my-leader-def
      "gl" '(:ignore t :wk "git link")
      "gll" 'git-link
      "glc" 'git-link-commit
      "glh" 'git-link-homepage))
#+END_SRC
TODO: commentary
#+BEGIN_SRC emacs-lisp
  (use-package browse-at-remote
    :general
    (my-leader-def
      "glg" 'browse-at-remote))

  (defhydra hydra-my-git-menu (global-map "<f7>"
                                          :color blue
                                          :hint nil)
    "
  ^Navigate^        ^Action^               ^Info^
  ^^^^^^^^^^^^---------------------------------------------------
  _j_: next hunk    _s_: stage hunk        _d_: diff
  _k_: prev hunk    _S_: stage file        _c_: show commit
  ^ ^               _U_: unstage file      _g_: magit status
  ^ ^               ^ ^                    _t_: git timemachine
  ^ ^               ^ ^                    ^ ^
  "
    ("j" git-gutter:next-hunk)
    ("k" git-gutter:previous-hunk)
    ("s" git-gutter:stage-hunk)
    ("S" magit-stage-file)
    ("U" magit-unstage-file)
    ("c" git-messenger:popup-show)
    ("g" magit-status :exit t)
    ("d" magit-diff-buffer-file)
    ("t" git-timemachine :exit t)
    ("q" quit-window "quit-window")
    ("<ESC>" git-gutter:update-all-windows "quit" :exit t))

  (defhydra hydra-my-git-timemachine-menu (:color blue)
    ("s" git-timemachine "start")
    ("j" git-timemachine-show-next-revision "next revision")
    ("k" git-timemachine-show-previous-revision "prev revision")
    ("c" git-timemachine-show-current-revision "curr revision")
    ("<ESC>" git-timemachine-show-current-revision "quit" :exit t))
#+END_SRC
TODO: commentary
#+BEGIN_SRC emacs-lisp
  (setq exec-path (append exec-path '("/Users/andrew.thompson/go/bin/")))
  (setq exec-path (append exec-path '("/opt/homebrew/bin/")))

  ;; I can't quite get this to work for some reason
  ;; (use-package exec-path-from-shell
  ;;   :straight nil
  ;;   :ensure t
  ;;   :config
  ;;   (exec-path-from-shell-initialize))

  ;; (when (eq system-type 'darwin)
  ;;   (mac-auto-operator-composition-mode))

  (when (eq system-type 'darwin)
    (setq python-shell-interpreter "/usr/local/bin/python3"))

  (when (eq system-type 'darwin)
    (setq visible-bell nil
          ring-bell-function 'flash-mode-line)
    (defun flash-mode-line ()
      (invert-face 'mode-line)
      (run-with-timer 0.1 nil #'invert-face 'mode-line)))

  (when (eq system-type 'darwin)
    (setq magit-git-executable "/usr/bin/git"))
#+END_SRC

TODO: commentary
#+BEGIN_SRC emacs-lisp
  (use-package restart-emacs
    :defer t)
#+END_SRC

TODO: commentary
#+BEGIN_SRC emacs-lisp
  (use-package restclient
    :defer  t)

  (use-package company-restclient
    :defer t)

  (use-package ob-restclient
    :defer t)
#+END_SRC





This is just a little function to open today's journal file.
#+BEGIN_SRC emacs-lisp
  (defun my/today ()
    "Create Org file from skeleton with current time as name."
    (interactive)
    (find-file (format-time-string (concat my/org-dir "journal/%Y-%m-%d.org"))))
  ;  (insert "Skeleton contents"))
#+END_SRC

[[https://www.gnu.org/software/emacs/manual/html_node/emacs/Saving-Emacs-Sessions.html][~desktop~]] saves the state of Emacs and restores it on restart.
#+BEGIN_SRC emacs-lisp
  (use-package desktop
    :straight nil
    :init
    (desktop-save-mode 1))
#+END_SRC

** LSP Mode
[[https://emacs-lsp.github.io/lsp-mode/][~lsp-mode~]] is an integration with various Language Server
Protocol implementations, giving Emacs an IDE like experience.
#+BEGIN_SRC emacs-lisp
  (use-package lsp-mode
    :hook
    (lsp-mode . lsp-enable-which-key-integration)
    (go-mode . lsp-deferred)
    :commands lsp
    :custom
    ;; This interferes with the existing company-mode setup if populated
    (lsp-completion-provider :none)
    :general
    (my-leader-def
      "p" '(hydra-lsp/body :wk "lsp-mode"))
    :config
    (setq lsp-file-watch-threshold 500)
    :custom-face
    (lsp-face-highlight-read ((t (:background "gray"))))
    (lsp-face-highlight-textual ((t (:background "gray"))))
    (lsp-face-highlight-write ((t (:background "SteelBlue1"))))
    (lsp-ui-doc-background ((t (:background "black"))))
    :hydra
    (hydra-lsp (:exit t :hint nil)
      "
   Buffer^^               Server^^                   Symbol
  -------------------------------------------------------------------------------------
   [_f_] format           [_M-r_] restart            [_d_] declaration  [_i_] implementation  [_o_] documentation
   [_m_] imenu            [_S_]   shutdown           [_j_] definition   [_t_] type            [_r_] rename
   [_x_] execute action   [_M-s_] describe session   [_R_] references   [_s_] signature       [_a_] actions"
      ("d" lsp-find-declaration)
      ("j" lsp-ui-peek-find-definitions)
      ("R" lsp-ui-peek-find-references)
      ("i" lsp-ui-peek-find-implementation)
      ("t" lsp-find-type-definition)
      ("s" lsp-signature-help)
      ("o" lsp-describe-thing-at-point)
      ("r" lsp-rename)
      ("a" helm-lsp-code-actions)

      ("f" lsp-format-buffer)
      ("m" lsp-ui-imenu)
      ("x" lsp-execute-code-action)

      ("M-s" lsp-describe-session)
      ("M-r" lsp-restart-workspace)
      ("S" lsp-shutdown-workspace)))

  (use-package lsp-ui
    :ensure t
    :commands lsp-ui-mode
    :config (setq lsp-ui-doc-enable t
                  lsp-ui-peek-enable t
                  lsp-ui-sideline-enable t
                  lsp-ui-imenu-enable t
                  lsp-ui-flycheck-enable t))

  (use-package helm-lsp
    :commands (helm-lsp-workspace-symbol))
#+END_SRC

** Other Programming Modes
*** General Programming Utilities

Line numbers are useful to have in various programming modes.
#+BEGIN_SRC emacs-lisp
  (use-package display-line-numbers
    :straight nil
    :ghook
    ('prog-mode-hook #'display-line-numbers-mode))
#+END_SRC

We're using the ~paren~ package here to specify some default options when interacting with
parentheses.
#+BEGIN_SRC emacs-lisp
  (use-package paren
    :straight nil
    :custom
    ;; show matching paren without delay
    (show-paren-delay 0)
    :config
    ;; show matching parens by default
    (show-paren-mode +1))
#+END_SRC

[[https://github.com/Fanael/rainbow-delimiters][~rainbow-delimiters~]] highlights delimiters, like parentheses, brackets, or braces, according to
their depth. It makes it much easier to visually identify which closing braces matches which opening
one.
#+BEGIN_SRC emacs-lisp
  (use-package rainbow-delimiters
    :hook (prog-mode . rainbow-delimiters-mode)
    :config
    (setq show-paren-delay  0
          show-paren-style 'mixed))
#+END_SRC

*** Golang
[[https://github.com/dominikh/go-mode.el][~go-mode~]] adds some useful commands when working with
Go.
#+BEGIN_SRC emacs-lisp
  (use-package go-mode
    :mode "\\.go\\'"
    :custom
    (defun lsp-go-install-save-hooks ()
      (add-hook 'before-save-hook #'lsp-format-buffer t t)
      (add-hook 'before-save-hook #'lsp-organize-imports t t))
    (add-hook 'go-mode-hook #'lsp-go-install-save-hooks)
    :config
    (setq
     gofmt-command "goimports"
     lsp-go-env '((GOFLAGS . "-tags=integration")))
    (add-hook 'before-save-hook 'gofmt-before-save))
#+END_SRC

*** Java
Commenting this for now since its a real slow loader.  TODO possible candidate for ~:defer~?
#+BEGIN_SRC emacs-lisp
  ;; (use-package lsp-java
  ;;   :config (add-hook 'java-mode-hook 'lsp))
#+END_SRC

Gradle is one of the several build systems available for Java projects.
#+BEGIN_SRC emacs-lisp
  (use-package gradle-mode
    :ensure t)
#+END_SRC

*** Javascript

TODO see how ~ensure-system-package~ works on windows.
#+BEGIN_SRC emacs-lisp
  (use-package js2-mode
    :mode "\\.js$"
    :hook (js2-mode . lsp)
    :interpreter "node"
    ;; commenting below line since I've removed this functionality for now
    ;; :ensure-system-package ((typescript-language-server . "npm i -g typescript-language-server")
    ;; (eslint_d . "npm i -g eslint_d"))
    :custom
    ;; set the indent level to 2
    (js2-basic-offset 2)
    (js-chain-indent t)
    (js-indent-level 2)
    ;; use eslint_d instead of eslint for faster linting
    (flycheck-javascript-eslint-executable "eslint_d"))

  (use-package json-mode
    :mode "\\.json\\'")
#+END_SRC

[[https://web-mode.org/][~web-mode~]] is a package for editing HTML.
#+BEGIN_SRC emacs-lisp
  (use-package web-mode
    :defer t
    :preface
    (defun my-web-mode-hook ()
      ;; set the html indent to 2
      (setq web-mode-markup-indent-offset 2)
      ;; highlight matching elements in html
      (setq web-mode-enable-current-element-highlight 1))
    :hook (web-mode . my-web-mode-hook)
    :init
    (add-hook 'web-mode-before-auto-complete-hooks
              '(lambda ()
                 (let ((web-mode-cur-language
                        (web-mode-language-at-pos))))))
    (add-to-list `auto-mode-alist '("\\.html?\\'" . web-mode))
    (add-to-list `auto-mode-alist '("\\.css\\'" . web-mode)))
#+END_SRC

*** Python
#+BEGIN_SRC emacs-lisp
  (use-package python
    :mode "\\.py\\'"
    :ghook
    ('python-mode-hook #'lsp)
    :general
    (my-local-leader-def 'python-mode-map
      "er" 'python-shell-send-region
      "eb" 'python-shell-send-buffer
      "ef" 'python-shell-send-file
      "es" 'python-shell-send-string))

  (use-package pipenv
    :hook ((python-mode . pipenv-mode)
           (hy-mode . pipenv-mode))
    :init
    (setq pipenv-projectile-after-switch-function #'pipenv-projectile-after-switch-extended))
#+END_SRC

*** Angular
#+BEGIN_SRC emacs-lisp
(use-package ng2-mode)
#+END_SRC

*** Rust
#+BEGIN_SRC emacs-lisp
(use-package rustic)
#+END_SRC


#+BEGIN_SRC emacs-lisp
(use-package dap-mode)
#+END_SRC

*** Yaml
#+BEGIN_SRC emacs-lisp
  (use-package yaml-mode
    :defer t)
#+END_SRC

*** Markdown
#+BEGIN_SRC emacs-lisp
  (use-package markdown-mode
    :mode ("README\\.md\\'" . gfm-mode)
    :init (setq markdown-command "multimarkdown"))
#+END_SRC

*** Terraform
#+BEGIN_SRC emacs-lisp
  (use-package terraform-mode
    :ensure t)
#+END_SRC

*** SQL

#+BEGIN_SRC emacs-lisp
  (use-package sqlformat
    :ensure t
    :init
    ;(add-hook 'sql-mode-hook 'sqlformat-on-save-mode)
    :config
    (setq sqlformat-command 'pgformatter))
#+END_SRC


*** Docker
[[https://github.com/spotify/dockerfile-mode][~dockerfile-mode~]] provides some conveniences for
editing Dockerfiles.

[[https://github.com/Silex/docker.el][~docker.el~]] allows Docker to be managed from within Emacs.

#+BEGIN_SRC emacs-lisp
  (use-package dockerfile-mode
    :defer t)

  (use-package docker
    :defer t)
#+END_SRC

*** Lisp
There's a bunch of Lispy stuff here that I don't use much. I should consider getting rid of it in
due course. Or I should consider writing more lisp...
#+BEGIN_SRC emacs-lisp
  (which-key-add-major-mode-key-based-replacements 'clojure-mode "C-c e" "eval")
  (which-key-add-major-mode-key-based-replacements 'emacs-lisp-mode "C-c e" "eval")
  (which-key-add-major-mode-key-based-replacements 'hy-mode "C-c e" "eval")
  (which-key-add-major-mode-key-based-replacements 'lisp-interaction-mode "C-c e" "eval")
  (which-key-add-major-mode-key-based-replacements 'scheme-mode "C-c e" "eval")
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (defconst my-lisp-mode-hooks
    '(lisp-mode-hook
      sly-mrepl-mode-hook
      emacs-lisp-mode-hook
      scheme-mode-hook
      geiser-repl-mode-hook
      hy-mode-hook
      inferior-hy-mode-hook
      clojure-mode-hook
      cider-repl-mode-hook))

  (defun my-lisp-setup ()
    (electric-pair-mode -1))

  (my-leader-def
    :keymaps 'emacs-lisp-mode-map
    "eb" 'eval-buffer
    "el" 'eval-last-sexp
    "ed" 'eval-defun
    "er" 'eval-region)

  (my-leader-def
    :keymaps 'lisp-interaction-mode-map
    "eb" 'eval-buffer
    "el" 'eval-last-sexp
    "ed" 'eval-defun
    "er" 'eval-region)

  (add-hook 'emacs-lisp-mode-hook 'turn-on-eldoc-mode)
  (add-hook 'lisp-interaction-mode-hook 'turn-on-eldoc-mode)
  (add-hook 'ielm-mode-hook 'turn-on-eldoc-mode)


  (use-package sly
    :defer t
    :hook (sly-mrepl-mode . rainbow-delimiters-mode)
    :general
    (my-local-leader-def
      :keymaps 'lisp-mode-map
      "eb" 'sly-eval-buffer
      "el" 'sly-eval-last-expression
      "ed" 'sly-eval-defun
      "er" 'sly-eval-region)
    :config
    (setq inferior-lisp-program "/usr/bin/sbcl"))

  (use-package sly-quicklisp
    :after sly)

  (use-package sly-asdf
    :after sly)

  (use-package hy-mode
    :mode "\\.hy\\'"
    :general
    (my-local-leader-def 'hy-mode-map
      "er" 'hy-shell-eval-region
      "eb" 'hy-shell-eval-buffer
      "el" 'hy-shell-eval-last-sexp
      "ed" 'hy-shell-eval-current-form))
#+END_SRC

This is a scheme mode. I don't really use it much.
#+BEGIN_SRC emacs-lisp
  (use-package geiser
    :defer t
    :general
    (my-local-leader-def
      :keymaps 'scheme-mode-map
      "r" 'run-geiser
      "er" 'geiser-eval-region
      "eR" 'geiser-eval-region-and-go
      "eb" 'geiser-eval-buffer
      "eB" 'geiser-eval-buffer-and-go
      "ed" 'geiser-eval-definition
      "eD" 'geiser-eval-definition-and-go
      "el" 'geiser-eval-eval-sexp)
    :custom
    (geiser-active-implementations '(guile mit racket)))
#+END_SRC

*** Tree Sitter
[[https://emacs-tree-sitter.github.io][~tree-sitter~]] provides a much improved code highlighting and allows Emacs to understand the
structure of code that I'm editing. Note that this part of core Emacs from v29 onwards.
#+begin_src emacs-lisp
  (use-package tree-sitter
    :init
    (add-hook 'tree-sitter-after-on-hook #'tree-sitter-hl-mode)
    (global-tree-sitter-mode))

  (use-package tree-sitter-langs
    :after tree-sitter)
#+end_src
** Navigation
[[https://github.com/abo-abo/avy][~avy~]] is an easy way to jump around any visible buffers. Hit ~C-'~ and hit a few characters, then
select from the list of options.
#+BEGIN_SRC emacs-lisp
  (use-package avy
    :config (setq avy-background t)
    :general ("C-'" 'avy-goto-char-timer))
#+END_SRC

[[https://github.com/rolandwalker/back-button][~back-button~]] is an improvement on the existing ~pop-global-mark~ functionality by providing a visual
representation of your location in the ring.
#+BEGIN_SRC emacs-lisp
  (use-package back-button
    :straight (back-button :host github :repo "rolandwalker/back-button")
    :general
    (my-leader-def
      "k" '(hydra-back-button/body :wk "back-button"))
    :config
    (back-button-mode 1)
    :hydra
    (hydra-back-button (:color red :hint nil)
        "
    Local         Global
  --------------------------------
    _t_ forward   _e_ forward
    _s_ backward  _n_ backward
    "
      ("e" back-button-global-forward)
      ("n" back-button-global-backward)
      ("t" back-button-local-forward)
      ("s" back-button-local-backward)))
#+END_SRC

[[https://github.com/Malabarba/beacon][~beacon~]] highlights the cursor location when scrolling or switching buffers.
#+BEGIN_SRC emacs-lisp
  (use-package beacon
    :diminish
    :config
    (setq beacon-color "#666600")
    (beacon-mode 1))
#+END_SRC

** Window Management

[[https://github.com/abo-abo/ace-window][~ace-window~]] allows for easy switching between windows within a frame, splitting windows and moving and
copying windows.
#+BEGIN_SRC emacs-lisp
  (use-package ace-window
    :general
    ("C-x o" 'ace-window)
    :config
    (setq aw-keys '(?a ?r ?s ?t ?n ?e ?i ?o)))
#+END_SRC

[[https://github.com/dimitri/switch-window][~switch-window~]] allows for easy switching between windows within a frame. It's slightly better than
~ace-window~ for that basic task as the labels for the windows are larger. However, ~ace-window~ is
worth keeping around for other functionality.
#+BEGIN_SRC emacs-lisp
  (use-package switch-window
    :general
    ("M-o" 'switch-window)
    :config
    (setq switch-window-shortcut-style 'qwerty))
#+END_SRC

[[https://depp.brause.cc/eyebrowse/][~eyebrowse~]] is a tool for keeping track you window configurations. Use ~C-c C-w~ to see the bindings
with ~which-key~. ~eyebrowse-restore~ allows those window configurations to be persisted across
sessions.
#+BEGIN_SRC emacs-lisp
  (use-package eyebrowse
    :ensure t
    :init
    (eyebrowse-mode t))

  (use-package eyebrowse-restore
    :ensure t
    :config
    (eyebrowse-restore-mode))
#+END_SRC

[[https://www.gnu.org/software/emacs/manual/html_node/emacs/Window-Convenience.html#index-winner_002dmode][~winner-mode~]] tracks changes in window configuration for a frame so that they can be undone or
redone.
#+BEGIN_SRC emacs-lisp
  (use-package winner
    :commands winner-mode
    :init (winner-mode t))
#+END_SRC

These are various functions for manipulating window size.
#+BEGIN_SRC emacs-lisp
  (defun hydra-move-splitter-left (delta)
    "Move window splitter left."
    (interactive "p")
    (let ((windmove-wrap-around nil))
      (if (windmove-find-other-window 'right)
          (shrink-window-horizontally delta)
        (enlarge-window-horizontally delta))))

  (defun hydra-move-splitter-right (delta)
    "Move window splitter right."
    (interactive "p")
    (let ((windmove-wrap-around nil))
      (if (windmove-find-other-window 'right)
          (enlarge-window-horizontally delta)
        (shrink-window-horizontally delta))))

  (defun hydra-move-splitter-up (delta)
    "Move window splitter up."
    (interactive "p")
    (let ((windmove-wrap-around nil))
      (if (windmove-find-other-window 'up)
          (enlarge-window delta)
        (shrink-window delta))))

  (defun hydra-move-splitter-down (delta)
    "Move window splitter down."
    (interactive "p")
    (let ((windmove-wrap-around nil))
      (if (windmove-find-other-window 'up)
          (shrink-window delta)
        (enlarge-window delta))))
#+END_SRC

Now we've got a hydra to make the various window management functions easily accessible.
#+BEGIN_SRC emacs-lisp
  (defhydra hydra-window-delux (:hint nil)
    "
      ^Movement^        ^Split^          ^Switch^            ^Resize^      ^Eyebrowse^
      -----------------------------------------------------------------------------
      _n_ ←             _v_ertical       _b_uffer            _l_ X←        _c_lose config
      _e_ ↓             _h_orizontal     _f_ind files        _u_ X↓        _r_ename config
      _i_ ↑             _z_ undo         _a_ce 1             _y_ X↑        _1_ setup 1
      _o_ →             _Z_ reset        _s_wap              _'_ X→        _2_ setup 2
      _F_ollow          _D_lt Other      _S_ave              _m_aximize    _3_ setup 3
      _q_ quit          _O_nly this      _d_elete            _=_ balance   _4_ setup 4
      "
    ;; Movement
    ("n" windmove-left )
    ("e" windmove-down )
    ("i" windmove-up )
    ("o" windmove-right )
    ("F" follow-mode)

    ;; Resize
    ("l" hydra-move-splitter-left)
    ("u" hydra-move-splitter-down)
    ("y" hydra-move-splitter-up)
    ("'" hydra-move-splitter-right)
    ("m" ace-maximize-window)
    ("=" balance-windows)

    ;; Split
    ("v" (lambda ()
           (interactive)
           (split-window-right)
           (windmove-right)))
    ("h" (lambda ()
           (interactive)
           (split-window-below)
           (windmove-down)))
    ("z" (progn
           (winner-undo)
           (setq this-command 'winner-undo)))
    ("Z" winner-redo)
    ("D" (lambda ()
           (interactive)
           (ace-window 16)
           (add-hook 'ace-window-end-once-hook
                     'hydra-window/body)))
    ("O" delete-other-windows)

    ;; Switch
    ("b" helm-mini)
    ("f" helm-find-files)
    ("a" (lambda ()
           (interactive)
           (ace-window 1)
           (add-hook 'ace-window-end-once-hook
                     'hydra-window/body)))
    ("s" (lambda ()
           (interactive)
           (ace-window 4)
           (add-hook 'ace-window-end-once-hook
                     'hydra-window/body)))
    ("S" save-buffer)
    ("d" delete-window)

    ;; Eyebrowse
    ("c" eyebrowse-close-window-config)
    ("r" eyebrowse-rename-window-config)
    ("0" eyebrowse-switch-to-window-config-0)
    ("1" eyebrowse-switch-to-window-config-1)
    ("2" eyebrowse-switch-to-window-config-2)
    ("3" eyebrowse-switch-to-window-config-3)
    ("4" eyebrowse-switch-to-window-config-4)
    ("5" eyebrowse-switch-to-window-config-5)
    ("6" eyebrowse-switch-to-window-config-6)
    ("7" eyebrowse-switch-to-window-config-7)
    ("8" eyebrowse-switch-to-window-config-8)
    ("9" eyebrowse-switch-to-window-config-9)
    ("q" nil))
  (my-leader-def
    "w" '(hydra-window-delux/body :wk "Window Management"))
#+END_SRC

** IBuffer
IBuffer is a useful way of viewing all open buffers. This config adds some sensible grouping along
with a useful hydra.
#+BEGIN_SRC emacs-lisp
  (use-package ibuffer
    :straight nil
    :config
    (setq
     ;; hide empty filter groups
     ibuffer-show-empty-filter-groups nil
     ibuffer-formats
     '((mark modified read-only vc-status-mini " "
             (name 18 18 :left :elide)
             " "
             (size 9 -1 :right)
             " "
             (mode 16 16 :left :elide)
             " "
             (vc-status 16 16 :left)
             " "
             vc-relative-file))
     ibuffer-saved-filter-groups
     '(("home"
        ("system-config" (or (filename . "dotfiles")
                             (filename . "emacs-config")))
        ("Org" (or (mode . org-mode)
                   (filename . "OrgMode")))
        ("code" (or (filename . "code")
                    (filename . ".py")
                    (filename . ".go")
                    (filename . ".rs")
                    (filename . ".java")))
        ("Web Dev" (or (mode . html-mode)
                       (mode . css-mode)))
        ("Directories" (mode . dired-mode))
        ("Help" (or (name . "\*Help\*")
                    (name . "\*Apropos\*")
                    (name . "\*info\*")))
        ("Builtin" (or (name . "\*Messages\*")
                       (name . "\*Completions\*")
                       (name . "\*Backtrace\*")
                       (name . "\*Compile-Log\*")
                       (name . "\*Calendar\*")
                       (name . "\*Calculator\*")
                       (name . "'*Scratch\*"))))))
    :hook
    (ibuffer-mode .
                  (lambda ()
                    (ibuffer-auto-mode 1)
                    (ibuffer-switch-to-saved-filter-groups "home")))

    :hydra (hydra-ibuffer-main (:color pink :hint nil)
                               "
    ^Mark^         ^Actions^         ^View^          ^Select^              ^Navigation^
    _m_: mark      _D_: delete       _g_: refresh    _q_: quit             _i_:   ↑    _n_
    _u_: unmark    _s_: save marked  _S_: sort       _TAB_: toggle         _RET_: visit
    _*_: specific  _a_: all actions  _/_: filter     _o_: other window     _e_:   ↓    _o_
    _t_: toggle    _._: toggle hydra _H_: help       C-o other win no-select
    "
                               ("m" ibuffer-mark-forward)
                               ("u" ibuffer-unmark-forward)
                               ("*" hydra-ibuffer-mark/body :color blue)
                               ("t" ibuffer-toggle-marks)

                               ("D" ibuffer-do-delete)
                               ("s" ibuffer-do-save)
                               ("a" hydra-ibuffer-action/body :color blue)

                               ("g" ibuffer-update)
                               ("S" hydra-ibuffer-sort/body :color blue)
                               ("/" hydra-ibuffer-filter/body :color blue)
                               ("H" describe-mode :color blue)

                               ("n" ibuffer-backward-filter-group)
                               ("i" ibuffer-backward-line)
                               ("o" ibuffer-forward-filter-group)
                               ("e" ibuffer-forward-line)
                               ("RET" ibuffer-visit-buffer :color blue)

                               ("TAB" ibuffer-toggle-filter-group)

                               ("O" ibuffer-visit-buffer-other-window :color blue)
                               ("q" quit-window :color blue)
                               ("." nil :color blue))

    :hydra (hydra-ibuffer-mark (:color teal :columns 5
                                       :after-exit (hydra-ibuffer-main/body))
                               "Mark"
                               ("*" ibuffer-unmark-all "unmark all")
                               ("M" ibuffer-mark-by-mode "mode")
                               ("m" ibuffer-mark-modified-buffers "modified")
                               ("u" ibuffer-mark-unsaved-buffers "unsaved")
                               ("s" ibuffer-mark-special-buffers "special")
                               ("r" ibuffer-mark-read-only-buffers "read-only")
                               ("/" ibuffer-mark-dired-buffers "dired")
                               ("e" ibuffer-mark-dissociated-buffers "dissociated")
                               ("h" ibuffer-mark-help-buffers "help")
                               ("z" ibuffer-mark-compressed-file-buffers "compressed")
                               ("b" hydra-ibuffer-main/body "back" :color blue))

    :hydra (hydra-ibuffer-action (:color teal :columns 4
                                         :after-exit
                                         (if (eq major-mode 'ibuffer-mode)
                                             (hydra-ibuffer-main/body)))
                                 "Action"
                                 ("A" ibuffer-do-view "view")
                                 ("E" ibuffer-do-eval "eval")
                                 ("F" ibuffer-do-shell-command-file "shell-command-file")
                                 ("I" ibuffer-do-query-replace-regexp "query-replace-regexp")
                                 ("H" ibuffer-do-view-other-frame "view-other-frame")
                                 ("N" ibuffer-do-shell-command-pipe-replace "shell-cmd-pipe-replace")
                                 ("M" ibuffer-do-toggle-modified "toggle-modified")
                                 ("O" ibuffer-do-occur "occur")
                                 ("P" ibuffer-do-print "print")
                                 ("Q" ibuffer-do-query-replace "query-replace")
                                 ("R" ibuffer-do-rename-uniquely "rename-uniquely")
                                 ("T" ibuffer-do-toggle-read-only "toggle-read-only")
                                 ("U" ibuffer-do-replace-regexp "replace-regexp")
                                 ("V" ibuffer-do-revert "revert")
                                 ("W" ibuffer-do-view-and-eval "view-and-eval")
                                 ("X" ibuffer-do-shell-command-pipe "shell-command-pipe")
                                 ("b" nil "back"))

    :hydra (hydra-ibuffer-sort (:color amaranth :columns 3)
                               "Sort"
                               ("i" ibuffer-invert-sorting "invert")
                               ("a" ibuffer-do-sort-by-alphabetic "alphabetic")
                               ("v" ibuffer-do-sort-by-recency "recently used")
                               ("s" ibuffer-do-sort-by-size "size")
                               ("f" ibuffer-do-sort-by-filename/process "filename")
                               ("m" ibuffer-do-sort-by-major-mode "mode")
                               ("b" hydra-ibuffer-main/body "back" :color blue))

    :hydra (hydra-ibuffer-filter (:color amaranth :columns 4)
                                 "Filter"
                                 ("m" ibuffer-filter-by-used-mode "mode")
                                 ("M" ibuffer-filter-by-derived-mode "derived mode")
                                 ("n" ibuffer-filter-by-name "name")
                                 ("c" ibuffer-filter-by-content "content")
                                 ("e" ibuffer-filter-by-predicate "predicate")
                                 ("f" ibuffer-filter-by-filename "filename")
                                 (">" ibuffer-filter-by-size-gt "size")
                                 ("<" ibuffer-filter-by-size-lt "size")
                                 ("/" ibuffer-filter-disable "disable")
                                 ("b" hydra-ibuffer-main/body "back" :color blue))
    :general
    (:keymaps 'ibuffer-mode-map
              "." 'hydra-ibuffer-main/body)
    )
#+END_SRC

~uniqify~ renames buffers with the same name so that they're easier to distinguish.
#+BEGIN_SRC emacs-lisp
  (use-package uniquify
    :straight nil
    :config
    (setq uniquify-buffer-name-style 'forward
          uniquify-separator "/"
          ;; rename after killing uniquified
          uniquify-after-kill-buffer-p t
          ;; don't muck with special buffers
          uniquify-ignore-buffers-re "^\\*"))
#+END_SRC

** Unknown
I don't actually know what these snippets do! I should probably get rid of them in due course.
#+BEGIN_SRC emacs-lisp
  (defmacro my/with-advice (adlist &rest body)
    "Execute BODY with temporary advice in ADLIST.

  Each element of ADLIST should be a list of the form
    (SYMBOL WHERE FUNCTION [PROPS])
  suitable for passing to `advice-add'.  The BODY is wrapped in an
  `unwind-protect' form, so the advice will be removed even in the
  event of an error or nonlocal exit."
    (declare (debug ((&rest (&rest form)) body))
             (indent 1))
    `(progn
       ,@(mapcar (lambda (adform)
                   (cons 'advice-add adform))
                 adlist)
       (unwind-protect (progn ,@body)
         ,@(mapcar (lambda (adform)
                     `(advice-remove ,(car adform) ,(nth 2 adform)))
                   adlist))))

  (defun my/call-logging-hooks (command &optional verbose)
    "Call COMMAND, reporting every hook run in the process.
  Interactively, prompt for a command to execute.

  Return a list of the hooks run, in the order they were run.
  Interactively, or with optional argument VERBOSE, also print a
  message listing the hooks."
    (interactive "CCommand to log hooks: \np")
    (let* ((log     nil)
           (logger (lambda (&rest hooks)
                     (setq log (append log hooks nil)))))
      (my/with-advice
          ((#'run-hooks :before logger))
        (call-interactively command))
      (when verbose
        (message
         (if log "Hooks run during execution of %s:"
           "No hooks run during execution of %s.")
         command)
        (dolist (hook log)
          (message "> %s" hook)))
      log))
#+END_SRC
